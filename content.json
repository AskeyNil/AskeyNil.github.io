{"meta":{"title":"AskeyNil","subtitle":null,"description":null,"author":"AskeyNil","url":"https://askeynil.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-11-04T10:55:07.296Z","updated":"2020-11-04T10:55:07.296Z","comments":true,"path":"404.html","permalink":"https://askeynil.github.io/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-11-04T10:55:07.311Z","updated":"2020-11-04T10:55:07.311Z","comments":true,"path":"categories/index.html","permalink":"https://askeynil.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-04T10:55:07.310Z","updated":"2020-11-04T10:55:07.310Z","comments":true,"path":"about/index.html","permalink":"https://askeynil.github.io/about/index.html","excerpt":"","text":"关于本站关于我名称由来本站以记录学习，技术积累为主，可能会穿插一些读书笔记或观后感。因本人技术有限，尽可能保证技术类文章真实有效，可能会不定时审查，若参考出现问题，也请留言告诉我。 近期更新内容应该会围绕以下主题： ROS 2 Foxy 雅思备考 LeetCode 刷题 SLAM 小车相关 高中就爱上计算机，大学因为种种原因没有上计算机专业，在电气工程专业鬼混，大二爱上嵌入式，大三莫名走上 iOS 开发，而后兜兜转转又回到我爱的机器人行业。想要研究小车，想要研究 SLAM，想要研究智能家居，想要研究各种智能化。期待未来，未来可期。 一个果粉，深入苹果的坑，已无法出坑。 一个海迷，热爱索大。梦想、承诺、努力和冷静。 我有个野心，就是要成为世界第一的剑士。 我要带着她的份也一起努力，我要让她的名字响彻天堂。 语言能力： Swift（快忘光了） Objective-C（快忘光了） C++ Python JavaScript（正在研究） AskeyNil，名称可以拆分为两部分，Askey 和 Nil Askey 代表的是我的野心，你可以看成是 as key。我也正在为此不断努力 Nil 在 Swift 中代表的是空指针，类似于 C 语言中的 NULL。nil 后缀的使用来源于我的老师，希望能在这大千世界中不要迷失自己，空灵澄明。 引用《法言》中的一段话： “玄者一也，至空者何以为九？空即窍， 窍有九，故俗言九窍；然则此一与九非定数，有错综参伍存乎其间， 故不以一九名，而以《玄空》二字代之“"},{"title":"书签","date":"2020-11-04T10:55:07.311Z","updated":"2020-11-04T10:55:07.311Z","comments":false,"path":"bookmark/index.html","permalink":"https://askeynil.github.io/bookmark/index.html","excerpt":"","text":""},{"title":"日签","date":"2020-11-04T10:57:02.269Z","updated":"2020-11-04T10:57:02.269Z","comments":true,"path":"day-sign/index.html","permalink":"https://askeynil.github.io/day-sign/index.html","excerpt":"","text":"$.ajax({ url: \"https://api.github.com/repos/askeynil/imgs-day-sign/contents/2020\", success:function(res){ $(\".article-entry .gallery\").append(\"\") var url = \"https://cdn.jsdelivr.net/gh/askeynil/imgs-day-sign/2020/\" res.reverse().forEach(function(x){ $(\".gallery p\").append(``) }) } })"},{"title":"文章归档","date":"2020-11-04T10:55:07.310Z","updated":"2020-11-04T10:55:07.310Z","comments":true,"path":"archives/index.html","permalink":"https://askeynil.github.io/archives/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-11-04T10:55:07.311Z","updated":"2020-11-04T10:55:07.311Z","comments":true,"path":"friends/index.html","permalink":"https://askeynil.github.io/friends/index.html","excerpt":"","text":"$('#links > section.article.article-entry.l_friends').prepend(``) 各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称：AskeyNil 头像：http://blog.askeynil.com/avatar.png 网址：https://askeynil.github.io 标签：C++，机器人"},{"title":"LeetCode","date":"2020-11-04T10:55:07.339Z","updated":"2020-11-04T10:55:07.339Z","comments":false,"path":"leetcode/index.html","permalink":"https://askeynil.github.io/leetcode/index.html","excerpt":"","text":"题目均来自 LeetCode 中文官网 所有题解代码均托管在 GitHub 上 按题目类型分 数组 字符串 树 链表 数学 按解法分 动态规划 双指针 哈希表 排序 位运算 标记法 二分查找 按难度分 简单 中等 困难"},{"title":"便签","date":"2020-11-04T10:55:07.339Z","updated":"2020-11-04T10:55:07.339Z","comments":true,"path":"note/index.html","permalink":"https://askeynil.github.io/note/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-04T10:55:07.340Z","updated":"2020-11-04T10:55:07.340Z","comments":true,"path":"tags/index.html","permalink":"https://askeynil.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-04T10:55:07.341Z","updated":"2020-11-04T10:55:07.341Z","comments":true,"path":"timeline/index.html","permalink":"https://askeynil.github.io/timeline/index.html","excerpt":"","text":"2020.08.20 将博客主题和脚本使用 git submodule 管理 增加相关文章插件 hexo-related-popular-posts重新整理博客源码和重新部署脚本 2020.08.07 优化部分博客内容增加永久链接插件 hexo-abbrlink因“ LeanCloud 流控问题”，将后台管理切换到 Valine-Admin-Server使用 GitHub Actions 处理“ LeanCould 流控问题”，参考: 优雅解决LeanCloud流控问题根据 timeline 标签，添加最近的时间轴添加站点信息配置，增加字数统计和阅读时长插件 wordcount修改右键菜单，系统的右键菜单请使用 Ctrl + 右键 2020.08.01 编写日签 js添加日签相册。图片来源: 时间胶囊，日记签到所得。 2020.07 博客基于 volantis 重新出发Fork hexo-theme-volantis 管理博客源码完善关于页面添加闲谈模块，基于 Artitalk添加评论功能，基于 Valine添加评论管理页面，基于 valine-admin-document"},{"title":"","date":"2020-11-04T10:57:02.269Z","updated":"2020-11-04T10:57:02.269Z","comments":true,"path":"talk/index.html","permalink":"https://askeynil.github.io/talk/index.html","excerpt":"","text":""}],"posts":[{"title":"ROS2 CLI Tools","slug":"ROS2 CLI Tools","date":"2020-08-26T11:34:31.000Z","updated":"2020-09-02T02:36:03.000Z","comments":true,"path":"2020/ROS2-CLI-Tools.html","link":"","permalink":"https://askeynil.github.io/2020/ROS2-CLI-Tools.html","excerpt":"系统版本：MacOS 10.15.6（官方写的是支持 10.14） ROS版本：Foxy shell：zsh Mac：MacBook Pro (13-inch, 2016, Four Thunderbolt 3 Ports) 该文章总结了 ROS2 官网的 CLI Tools 介绍，如果需要更为详细的介绍请移步官网。且 Windows 不在文本讨论范围内。 本文主要介绍如下： 配置 ROS2 环境 ROS 2 nodes ROS 2 topics ROS 2 services ROS 2 actions ROS 2 parameters 创建 launch 文件 记录和回放数据 ROS1 和 ROS2 命令行工具的差异 全文篇幅可能较长，尽可能使用更精简的方式描述。","text":"系统版本：MacOS 10.15.6（官方写的是支持 10.14） ROS版本：Foxy shell：zsh Mac：MacBook Pro (13-inch, 2016, Four Thunderbolt 3 Ports) 该文章总结了 ROS2 官网的 CLI Tools 介绍，如果需要更为详细的介绍请移步官网。且 Windows 不在文本讨论范围内。 本文主要介绍如下： 配置 ROS2 环境 ROS 2 nodes ROS 2 topics ROS 2 services ROS 2 actions ROS 2 parameters 创建 launch 文件 记录和回放数据 ROS1 和 ROS2 命令行工具的差异 全文篇幅可能较长，尽可能使用更精简的方式描述。 配置 ROS2 环境1.加载核心 ROS 配置文件与 ROS1 一样，使用 ROS2 也需要加载 setup 配置文件 1. ~/ros2_foxy/ros2-osx/setup.zsh 注意：我的 shell 是 zsh，请使用你对应的 shell 的 setup，且路径请以你安装路径为准。 2. 添加核心配置文件到 shell 的启动脚本中官网的做法如下： 1echo &quot;. ~/ros2_foxy/ros2-osx/setup.zsh&quot; &gt;&gt; ~/.zshrc 我不太建议这种做法，如果是完全学习 ROS2，可以采取这种方式。这种方式的好处是你全局都可以使用 ROS2 的命令，坏处就是你也不知道何时你的其他程序会加载到 ROS2 环境中的库，然而实际情况这个库不是我想要的。所以我更建议下面这种方式： 1echo &quot;alias ros2_source=&#x27;. ~/ros2_foxy/ros2-osx/setup.zsh&#x27;&quot; &gt;&gt; ~/.zshrc 当我需要加载 ROS2 环境的时候，手动使用 ros2_source 命令即可。 3. 检查环境变量使用 printenv | grep -i ROS 命令查看当前的所有环境变量，如果设置正确至少应该会打印如下内容： 123ROS_DISTRO=foxyROS_PYTHON_VERSION=3ROS_VERSION=2 设置 ROS_DOMAIN_ID 确保局域网不同域的 ROS 数据不会误访问，我使用的 id 为 2。官网要求该数字必须是 0-232 之间的整数。 1echo &quot;export ROS_DOMAIN_ID=2&quot; &gt;&gt; ~/.zshrc ROS NodeROS Node 包含的命令如下： list info 前提条件运行了如下命令： 12. ~/ros2_foxy/ros2-osx/setup.zshros2 run turtlesim turtlesim_node listros2 node list 显示所有正在运行的节点。 当前运行 ros2 node list 显示如下 1/turtlesim info用法：ros2 node info &lt;node_name&gt; 例如当前有一个 /turtlesim 节点，使用如下命令： 1ros2 node info /turtlesim 显示的结果如下： 12345678910111213141516171819202122232425262728/turtlesim Subscribers: /parameter_events: rcl_interfaces/msg/ParameterEvent /turtle1/cmd_vel: geometry_msgs/msg/Twist Publishers: /parameter_events: rcl_interfaces/msg/ParameterEvent /rosout: rcl_interfaces/msg/Log /turtle1/color_sensor: turtlesim/msg/Color /turtle1/pose: turtlesim/msg/Pose Service Servers: /clear: std_srvs/srv/Empty /kill: turtlesim/srv/Kill /reset: std_srvs/srv/Empty /spawn: turtlesim/srv/Spawn /turtle1/set_pen: turtlesim/srv/SetPen /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute /turtle1/teleport_relative: turtlesim/srv/TeleportRelative /turtlesim/describe_parameters: rcl_interfaces/srv/DescribeParameters /turtlesim/get_parameter_types: rcl_interfaces/srv/GetParameterTypes /turtlesim/get_parameters: rcl_interfaces/srv/GetParameters /turtlesim/list_parameters: rcl_interfaces/srv/ListParameters /turtlesim/set_parameters: rcl_interfaces/srv/SetParameters /turtlesim/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically Service Clients: Action Servers: /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute Action Clients: 注：Subscribers、Publishers、Service Servers、Service Clients、Action Servers 和 Action Clients 的含义后面再进行介绍。 与 ROS1 的比较 命令 ROS1 ROS2 show rosnode list ros2 node list list rosnode show &lt;node_name&gt; ros2 node show &lt;node_name&gt; 使用起来几乎一致，但是有一些 ROS1 的命令 ROS2 没有，比如 kill、ping，在实际开发中这些命令也较少用到，不做讨论。 ROS Topic 命令 ROS1 ROS2 含义 echo rostopic echo /topic ros2 topic echo /topic 打印某个 topic 的内容 find rostopic find /topic ros2 topic find /topic 查找使用某个 topic 的节点 info rostopic info /topic ros2 topic info /topic 显示某个 topic 的发布者和订阅者的数量 list rostopic list ros2 topic list 显示当前 topic 的清单 pub rostopic pub /topic &quot;msg&quot; ros2 topic pub /topic &quot;msg&quot; 发送消息到一个指定的 topic 中 ROS Service 命令 ROS1 ROS2 含义 call rosservice call /service_name /service_type [values] ros2 service call /service_name /service_type [values] 给指定的服务端发送特定消息 find rosservice find /service_type ros2 service find /service_type 查找使用某个 Service 的节点 list rosservice list ros2 service list 显示当前 Service 的清单 ROS Action在 ROS1 中 ros action 的 cli 不存在。故不作对比，使用方式与前面两者非常相似。 命令 ROS Foxy 含义 info ros2 action info /action_name 显示某个 action 中 client 和 server 的数量 list ros2 action list 显示当前所有 action 的清单 send_goal ros2 action send_goal /action_name /action_type [goal] 发送一个 goal 到指定 action 中 ROS parametersparam 参数是节点所需的配置设置，可以是整数，浮点数，布尔值，字符串或列表。在 ros2 中参数是基于 service 构建的。依旧用表格的方式描述 ROS1 和 ROS2 中参数设计的差异。注：ROS2 的参数是存储在节点中的，ROS1 的参数是存储在 ROS Master 中的，所有在使用的时候一般会有一个节点名称的差距。 命令 ROS1 ROS2 含义 delete rosparam delete /parameter_name ros2 param delete /node_name /parameter_name 删除参数 dump rosparam dump file [namespace] ros2 param dump /node_name 保存参数 get rosparam get /parameter_name ros2 param get /node_name /parameter_name 获取参数 list rosparam list ros2 param list [node_name] 查看参数列表 set rosparam set /parameter_name value ros2 param set /node_name /parameter_name value 设置参数 ROS Interfaceinterface 是 ROS2 中将 ROS1 中的 rosmsg 和 rossrv 命令合并以后的命令，使用起来更为统一且简洁。先看看 rosmsg 和 rossrv 执行 rosmsg -v 1234567891011rosmsg is a command-line tool for displaying information about ROS Message types.Commands: rosmsg show Show message description rosmsg info Alias for rosmsg show rosmsg list List all messages rosmsg md5 Display message md5sum rosmsg package List messages in a package rosmsg packages List packages that contain messagesType rosmsg &lt;command&gt; -h for more detailed usage 执行 rossrv -h 1234567891011rossrv is a command-line tool for displaying information about ROS Service types.Commands: rossrv show Show service description rossrv info Alias for rossrv show rossrv list List all services rossrv md5 Display service md5sum rossrv package List services in a package rossrv packages List packages that contain servicesType rossrv &lt;command&gt; -h for more detailed usage 通过 -h 命令可以发现，这两个命令使用方式非常相似 ，结果相似也非常相似。我们在来看看ros2 interface -h 123456789101112131415usage: ros2 interface [-h] Call `ros2 interface &lt;command&gt; -h` for more detailed usage. ...Show information about ROS interfacesoptional arguments: -h, --help show this help message and exitCommands: list List all interface types available package Output a list of available interface types within one package packages Output a list of packages that provide interfaces proto Output an interface prototype show Output the interface definition Call `ros2 interface &lt;command&gt; -h` for more detailed usage. help 中已经将用法讲的很清楚了，这里就不对比了。记录不同类型的打印结果。 ros2 interface show std_msgs/msg/Int8 123456# This was originally provided as an example message.# It is deprecated as of Foxy# It is recommended to create your own semantically meaningful message.# However if you would like to continue using this please use the equivalent in example_msgs.int8 data ros2 interface show std_srvs/srv/Empty 1--- ros2 interface show turtlesim/action/RotateAbsolute 12345678# The desired heading in radiansfloat32 theta---# The angular displacement in radians to the starting positionfloat32 delta---# The remaining rotation in radiansfloat32 remaining 注：msg、srv 和 action 消息的具体写法后面会在进行详细的介绍。 ROS Launch在 ROS1 中 lauch 使用 xml 格式定义，使用的内容相对比较有限。然而在 ROS2 中 launch 重新设计，采用 Python 脚本的形式进行启动，大致模板可以使用如下： 123456789101112from launch import LaunchDescriptionfrom launch_ros.actions import Nodedef generate_launch_description(): return LaunchDescription([ Node( package=&quot;turtlesim&quot;, executable=&quot;turtlesim_node&quot;, name=&quot;sim&quot;, ) ]) LaunchDescription 中传入了一个 Node 的数组，Node代表了所有的节点信息。参数的含义和使用列举如下： 参数名称 含义 类型 举例 package 包名 str turtlesim executable 可执行文件的名称 str turtlesim_node name 节点名称 str sim namespace 工作空间名称 str turtlesim1 parameters 参数列表 [path 或 Map(key, value)] [&#123;&quot;background_r&quot;: 0&#125;] 或 [&quot;./sim.yaml&quot;] remappings 映射名称 [tuple] [(&#39;/turtlesim1/turtle1/pose&#39;, &#39;/turtlesim1/turtle1/pose_remap&#39;)] 假设我们将之前的模板内容写入到 turtlesim_start.launch.py 中，在加载 ros 环境后，只需执行如下命令即可运行 launch 文件 1ros2 launch turtlesim_start.launch.py 终端大致打印内容如下： 12345[INFO] [launch]: All log files can be found below /Users/askeynil/.ros/log/2020-09-02-19-33-18-140633-AskeyNildeMacBook-Pro.local-22416[INFO] [launch]: Default logging verbosity is set to INFO[INFO] [turtlesim_node-1]: process started with pid [22418][turtlesim_node-1] [INFO] [1599046399.308158593] [sim]: Starting turtlesim with node name /_ros2cli_daemon_1[turtlesim_node-1] [INFO] [1599046399.342564206] [sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000] ROS Bag该命令可以指定录制一段时间内发送的 topic 数据，以便后面在查询问题的时候进行复现。 命令 ROS1 ROS2 含义 info rosbag info &lt;bag_file_name&gt; ros2 bag info &lt;bag_file_name&gt; 查看 bag 中的详细内容 play rosbag play &lt;bag_file_name&gt; ros2 bag play &lt;bag_file_name&gt; 播放 bag 中的操作 record rosbag record -O &lt;output_name&gt; [topics [topics ...]] ros2 bag record -o &lt;output_name&gt; [topics [topics ...]] 录制指定 topic 操作","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Foxy","slug":"ROS/Foxy","permalink":"https://askeynil.github.io/categories/ROS/Foxy/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"https://askeynil.github.io/tags/ROS2/"},{"name":"CLI Tools","slug":"CLI-Tools","permalink":"https://askeynil.github.io/tags/CLI-Tools/"}]},{"title":"ROS2 Foxy 安装（基于 Mac OS 二进制）","slug":"ros2 foxy 安装（基于 Mac OS 二进制）","date":"2020-08-21T12:05:51.000Z","updated":"2020-08-26T11:31:38.000Z","comments":true,"path":"2020/ROS2-Foxy-macOS-Install-Binary.html","link":"","permalink":"https://askeynil.github.io/2020/ROS2-Foxy-macOS-Install-Binary.html","excerpt":"系统版本：MacOS 10.15.6（官方写的是支持 10.14） ROS版本：Foxy shell：zsh Mac：MacBook Pro (13-inch, 2016, Four Thunderbolt 3 Ports) 安装方式基本与官方的安装方式一致： https://index.ros.org/doc/ros2/Installation/Foxy/macOS-Install-Binary/","text":"系统版本：MacOS 10.15.6（官方写的是支持 10.14） ROS版本：Foxy shell：zsh Mac：MacBook Pro (13-inch, 2016, Four Thunderbolt 3 Ports) 安装方式基本与官方的安装方式一致： https://index.ros.org/doc/ros2/Installation/Foxy/macOS-Install-Binary/ 安装之前建议先将 brew 换用国内镜像源，当然即使更换了源也会出现少数地方比较慢需要科学上网的情况，比如 opencv 的安装。也可以不科学上网，仅仅只是慢，应该能下载成功。 安装必要依赖 Python3.8：ROS2 Foxy 开始默认支持 Python 3.8 123brew install python@3.8brew unlink pythonbrew link --force python@3.8 asio、tinyxml2：Fast-RTPS 依赖，用来订阅发布消息的组件。以后会详细介绍 DDS 1brew install asio tinyxml2 tinyxml、eigen、pcre、poco：机器人状态发布者的依赖 1brew install tinyxml eigen pcre poco opencv：非必须，但是视觉常常需要用到。安装它可能需要科学上网。如果没有会比较慢，耐心等待试试。 1brew install opencv openssl：用来加密，zshrc 根据你的 shell 进行调整 12brew install opensslecho &quot;export OPENSSL_ROOT_DIR=$(brew --prefix openssl)&quot; &gt;&gt; ~/.zshrc Rviz的依赖 1brew install qt freetype assimp rosbag2 需要的组件 1brew install console_bridge rcl_logging_log4cxx 的依赖 1brew install log4cxx spdlog Cyclone DDS 需要的组件 1brew install cunit rqt 的依赖 1234567brew install sip pyqt5ln -s /usr/local/share/sip/Qt5 /usr/local/share/sip/PyQt5brew install graphvizpython3 -m pip install pygraphviz pydot# 安装 pygraphviz 可能会遇到问题：error: Error locating graphviz。尝试使用下面命令解决# python3 -m pip install --install-option=&quot;--include-path=/usr/local/include/&quot; --install-option=&quot;--library-path=/usr/local/lib/&quot; pygraphviz SROS2的依赖 1python3 -m pip install lxml 命令行工具的依赖 1python3 -m pip install -U argcomplete catkin_pkg colcon-common-extensions coverage cryptography empy flake8 flake8-blind-except flake8-builtins flake8-class-newline flake8-comprehensions flake8-deprecated flake8-docstrings flake8-import-order flake8-quotes ifcfg lark-parser lxml mock mypy netifaces nose pep8 pydocstyle pydot pygraphviz pyparsing pytest-mock rosdep setuptools vcstool 禁用系统完整性保护（sip） 终端输入 csrutil status 如果显示的是 System Integrity Protection status: disabled. 则表示是禁用的，后面无需进行了。如果是 enabled 则继续往下进行。 重启电脑开机的同时按住 command + r 不要松手，直到出现白苹果 在实用工具中找到终端 输入命令：csrutil disable 如果得到结果为： Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect. 则说明禁用成功 安装 ROS 2 打开下载界面：https://github.com/ros2/ros2/releases 找到 ros2-foxy-xxx-macos-amd64.tar.bz2，我当前使用的下载链接为 ros2-foxy-20200807-macos-amd64.tar.bz2 下载后解压会有一个 ros2-osx 的文件夹，该文件就是 ros2 的源文件了 将其放在任何你想放在的文件夹内，官方将其放在了 ~/ros2_foxy 中。 使用简单的例子测试 ros2 加载环境 1. ~/ros2_foxy/ros2-osx/setup.zsh 打开 talker 1ros2 run demo_nodes_cpp talker 打开另一个终端，打开 listener（别忘了加载 ros 环境） 1ros2 run demo_nodes_py listener talker 打印如下 12[INFO] [1598014476.967367729] [talker]: Publishing: &quot;Hello World: 0&quot;[INFO] [1598014476.967367729] [talker]: Publishing: &quot;Hello World: 1&quot; linstener 打印如下 12[INFO] [1598014543.990184042] [listener]: I heard: [Hello World: 67][INFO] [1598014543.990184042] [listener]: I heard: [Hello World: 68] 安装后出现的问题 . ~/ros2_foxy/ros2-osx/setup.zsh 之后出现如下内容： 1[connext_cmake_module] Warning: The location at which Connext was found when the workspace was built [[&#x2F;Applications&#x2F;rti_connext_dds-5.3.1]] does not point to a valid directory, and the NDDSHOME environment variable has not been set. Support for Connext will not be available. 暂时将其忽略，没发现影响。 运行 rqt_graph 1The &#39;tango_icons_vendor&#39; package was not found - icons will not work 该报错导致 rqt 工具的图片都无法显示，解决办法暂时没有找到。","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Foxy","slug":"ROS/Foxy","permalink":"https://askeynil.github.io/categories/ROS/Foxy/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"https://askeynil.github.io/tags/ROS2/"},{"name":"install","slug":"install","permalink":"https://askeynil.github.io/tags/install/"}]},{"title":"git submodule 基本使用","slug":"git submodule","date":"2020-08-19T12:28:45.000Z","updated":"2020-08-20T13:12:17.000Z","comments":true,"path":"2020/use-of-git-submoudle.html","link":"","permalink":"https://askeynil.github.io/2020/use-of-git-submoudle.html","excerpt":"","text":"整理比较常用的与 submodule 有关的命令 添加子仓库 1git submodule add &lt;repository&gt; [&lt;path&gt;] 每个仓库执行指定命令。--recursive 递归查找子仓库 1git submodule foreach [--recursive] &lt;commands&gt; 删除 submodule 仓库 1git submodule deinit (--all | [--] &lt;path&gt;...) clone 仓库的时候同时下载子仓库 123456# 1. --recurse-submodules[=&lt;pathspec&gt;] 可以指定特定的仓库# 2. --recursive 递归所有仓库git clone [--recurse-submodules[=&lt;pathspec&gt;] | --recursive] &lt;repository&gt; [&lt;directory&gt;]# 如果是所有仓库，等同于git clone &lt;repository&gt; [&lt;directory&gt;]git submodule update --init --recursive","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Git","slug":"Coding/Git","permalink":"https://askeynil.github.io/categories/Coding/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://askeynil.github.io/tags/Git/"}]},{"title":"因时机械爪驱动","slug":"因时机械爪驱动","date":"2019-11-17T05:00:00.000Z","updated":"2019-11-17T05:00:00.000Z","comments":true,"path":"2019/32569ea8.html","link":"","permalink":"https://askeynil.github.io/2019/32569ea8.html","excerpt":"项目代码已托管到github上 https://github.com/AskeyNil/inspire_EG2_4B1 共两个版本 C++ Python","text":"项目代码已托管到github上 https://github.com/AskeyNil/inspire_EG2_4B1 共两个版本 C++ Python C++ 使用方法 将 cpp 文件夹复制到工程下 3rdparty 目录下，并改名为talon（注意，大小写敏感） 在项目的 CMakeLists.txt 中添加如下代码 1set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&#x2F;3rdparty&#x2F;talon) 上一步也可以将cpp中的cmake文件拷贝到你的CMAKE_MODULE_PATH中 使用find_package(Talon)导入package 在target_link_libraries中添加Talon，以此来使用代码。 以上… Python 使用方法 直接拖入项目中即可","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"驱动开发","slug":"Coding/驱动开发","permalink":"https://askeynil.github.io/categories/Coding/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"}]},{"title":"使用 C++ 实现复杂枚举","slug":"使用 C++ 实现复杂枚举","date":"2019-11-13T12:00:00.000Z","updated":"2019-11-13T12:00:00.000Z","comments":true,"path":"2019/cc-complex-enum.html","link":"","permalink":"https://askeynil.github.io/2019/cc-complex-enum.html","excerpt":"在实际使用 C++ 的过程中，经常需要使用到枚举，然而在 C++ 中并不能给枚举添加方法，属性等特性，如果要使用这些特性，需要通过一些特殊的办法来做到，对枚举进行一个封装。 以当前用到的封装移动方式为例","text":"在实际使用 C++ 的过程中，经常需要使用到枚举，然而在 C++ 中并不能给枚举添加方法，属性等特性，如果要使用这些特性，需要通过一些特殊的办法来做到，对枚举进行一个封装。 以当前用到的封装移动方式为例 1234567891011121314151617181920212223242526272829303132333435363738class URMoveState &#123;public: enum StateEnum &#123; MOVEC = 0, MOVEJ = 1, MOVEL = 2, MOVEP = 3 &#125;; StateEnum _state; explicit URMoveState(const StateEnum &amp;state) : _state(state) &#123;&#125;; // 重载等于 inline bool operator==(const URMoveState &amp;rhs) &#123; return _state == rhs._state; &#125; inline bool operator==(const StateEnum &amp;rhs) &#123; return _state == rhs; &#125; // 重载不等于 inline bool operator!=(const URMoveState &amp;rhs) &#123; return _state != rhs._state; &#125; inline bool operator!=(const StateEnum &amp;rhs) &#123; return _state != rhs; &#125; std::string name() &#123; switch (_state) &#123; case MOVEC:return &quot;movec&quot;; case MOVEJ:return &quot;movej&quot;; case MOVEL:return &quot;movel&quot;; case MOVEP:return &quot;movep&quot;; &#125; &#125; // and so on ...&#125;;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"C++","slug":"Coding/C","permalink":"https://askeynil.github.io/categories/Coding/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"},{"name":"Enum","slug":"Enum","permalink":"https://askeynil.github.io/tags/Enum/"}]},{"title":"xacro 语法总结","slug":"xacro 语法总结","date":"2019-11-09T03:00:00.000Z","updated":"2019-11-09T03:00:00.000Z","comments":true,"path":"2019/3f08735f.html","link":"","permalink":"https://askeynil.github.io/2019/3f08735f.html","excerpt":"xacro是为了解决在编写urdf文件过程中，出现的标签内容重复，但又不得不去写。一些值的计算有依赖的问题。为了和urdf文件区分，我们定义的模型文件名后缀为.xacro。 从功能的角度来说，xacro提供了属性定义，数学运算，条件判断和宏定义等功能。 注意：必须在robot标签中加入xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;属性！！ 该文件中注释不能用中文！！！ http://wiki.ros.org/xacro","text":"xacro是为了解决在编写urdf文件过程中，出现的标签内容重复，但又不得不去写。一些值的计算有依赖的问题。为了和urdf文件区分，我们定义的模型文件名后缀为.xacro。 从功能的角度来说，xacro提供了属性定义，数学运算，条件判断和宏定义等功能。 注意：必须在robot标签中加入xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;属性！！ 该文件中注释不能用中文！！！ http://wiki.ros.org/xacro 属性 属性的定义使用&lt;xacro:property&gt;标签完成，使用的时候用$&#123;属性名称&#125;来调用该参数。 例如： 123456&lt;!-- define --&gt;&lt;xacro:property name=&quot;the_radius&quot; value=&quot;2.1&quot; /&gt;&lt;xacro:property name=&quot;the_length&quot; value=&quot;4.5&quot; /&gt;&lt;!-- use --&gt;&lt;geometry type=&quot;cylinder&quot; radius=&quot;$&#123;the_radius&#125;&quot; length=&quot;$&#123;the_length&#125;&quot; /&gt; 数学运算 在变量的大括号中可以使用基本的数学运算，可以使用Python数学模块中的函数和常量 包括，但不限于以下： pi：π sin：正弦函数 cos：余弦函数 tan：正切函数 radians：角度值转弧度制 例如： 1234&lt;xacro:property name=&quot;R&quot; value=&quot;2&quot; /&gt;&lt;xacro:property name=&quot;alpha&quot; value=&quot;$&#123;30/180*pi&#125;&quot; /&gt;&lt;circle circumference=&quot;$&#123;2 * pi * R&#125;&quot; pos=&quot;$&#123;sin(alpha)&#125; $&#123;cos(alpha)&#125;&quot; /&gt;&lt;limit lower=&quot;$&#123;radians(-90)&#125;&quot; upper=&quot;$&#123;radians(90)&#125;&quot; effort=&quot;0&quot; velocity=&quot;$&#123;radians(75)&#125;&quot; /&gt; 条件判断语法： 123456&lt;xacro:if value=&quot;&lt;expression&gt;&quot;&gt; &lt;... some xml code here ...&gt;&lt;/xacro:if&gt;&lt;xacro:unless value=&quot;&lt;expression&gt;&quot;&gt; &lt;... some xml code here ...&gt;&lt;/xacro:unless&gt; 表达式中的结果必须是0、1、true或false，否则将会出现错误。 在&lt;expression&gt;中任何结果为布尔值的Python表达式都是可以的。 例子： 123456&lt;xacro:property name=&quot;var&quot; value=&quot;useit&quot;/&gt;&lt;xacro:if value=&quot;$&#123;var == &#x27;useit&#x27;&#125;&quot;/&gt;&lt;xacro:if value=&quot;$&#123;var.startswith(&#x27;use&#x27;) and var.endswith(&#x27;it&#x27;)&#125;&quot;/&gt;&lt;xacro:property name=&quot;allowed&quot; value=&quot;$&#123;[1,2,3]&#125;&quot;/&gt;&lt;xacro:if value=&quot;$&#123;1 in allowed&#125;&quot;/&gt; 宏定义 宏定义使用xacro:macro来定义一个宏，参数用空格分割，参数可以用:=来添加默认值 语法： 123456&lt;!-- define --&gt;&lt;xacro:macro name=&quot;&lt;name&gt;&quot; params=&quot;&lt;params&gt;&quot;&gt; &lt;... some xml code here ...&gt;&lt;/xacro:macro&gt;&lt;!-- use --&gt;&lt;xacro:&lt;name&gt; &lt;params&gt;=&quot;&quot; /&gt; 例子： 1234567891011121314151617181920212223242526272829&lt;xacro:macro name=&quot;ak_axis_x&quot;&gt; &lt;axis xyz=&quot;1 0 0&quot;/&gt;&lt;/xacro:macro&gt;&lt;xacro:macro name=&quot;ak_link&quot; params=&quot;name type:=box&quot;&gt; &lt;link name=&quot;$&#123;name&#125;&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;xacro:if value=&quot;$&#123;type == &#x27;box&#x27;&#125;&quot;&gt; &lt;box size=&quot;1 2 3&quot;/&gt; &lt;/xacro:if&gt; &lt;xacro:if value=&quot;$&#123;type == &#x27;cylinder&#x27;&#125;&quot;&gt; &lt;cylinder length=&quot;1&quot; radius=&quot;0.5&quot;/&gt; &lt;/xacro:if&gt; &lt;xacro:if value=&quot;$&#123;type == &#x27;sphere&#x27;&#125;&quot;&gt; &lt;sphere radius=&quot;1&quot;/&gt; &lt;/xacro:if&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt;&lt;/xacro:macro&gt;&lt;xacro:ak_axis_x /&gt;&lt;xacro:ak_link name=&quot;my_box&quot; /&gt;&lt;xacro:ak_link name=&quot;my_cylinder&quot; type=&quot;cylinder&quot;/&gt; 总结 标签 解释 属性 &lt;xacro:property&gt; 属性 name、value &lt;xacro:if&gt; 如果 value &lt;xacro:unless&gt; 如果不 value &lt;xacro:macro&gt; 宏定义 name、params 数学运算的时候可以使用Python中Math里面的函数 if判断的时候可以使用Python中所有能得到bool值的判断，比如in","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"URDF","slug":"URDF","permalink":"https://askeynil.github.io/tags/URDF/"},{"name":"xacro","slug":"xacro","permalink":"https://askeynil.github.io/tags/xacro/"}]},{"title":"URDF 中 link、joint 属性总结","slug":"URDF 中 link、joint 属性总结","date":"2019-11-08T00:00:00.000Z","updated":"2019-11-08T00:00:00.000Z","comments":true,"path":"2019/bcc307b4.html","link":"","permalink":"https://askeynil.github.io/2019/bcc307b4.html","excerpt":"此文用于记录URDF模型中最重要和最常用的两个标签，文章的内容大部分都来自官方 http://wiki.ros.org/urdf/XML/link http://wiki.ros.org/urdf/XML/joint 对于各个标签的理解和使用，不定时更新。","text":"此文用于记录URDF模型中最重要和最常用的两个标签，文章的内容大部分都来自官方 http://wiki.ros.org/urdf/XML/link http://wiki.ros.org/urdf/XML/joint 对于各个标签的理解和使用，不定时更新。 link各标签 子标签或属性（带&lt;&gt;为标签，不带为属性） 子标签和属性 描述 是否理解 name（必填） 用于描述 link 的名称 √ &lt;inertial&gt;（可选） 物理惯性 &lt;origin&gt; （可选） 位置和姿态 &lt;mass&gt; 质量 &lt;inertia&gt; 3x3的旋转惯性矩阵 &lt;visual&gt;（可选） 连杆的外观，可存在多个 √ name（可选） 名称 √ &lt;origin&gt; （可选） 位置和姿态 √ &lt;geometry&gt;（必填） 形状 √ &lt;material&gt;（可选） 纹理外观 √ &lt;collision&gt;（可选） 碰撞，可存在多个 name（可选） 名称 &lt;origin&gt; （可选） 位置和姿态 &lt;geometry&gt;（必填） 形状 针对上面的第二列中的子标签描述，同名的意义相同，只描述一次 子标签或属性（带&lt;&gt;为标签，不带为属性） 子标签和属性 描述 &lt;origin&gt;（可选） 位置和姿态 xyz（可选） x、y、z的偏移，以米为单位。 rpy（可选） x、y、z的旋转，以弧度为单位 &lt;mass&gt; value 质量 &lt;inertia&gt; ixx ixy ixz iyy iyz izz &lt;geometry&gt;（必填） &lt;box&gt; 长方体size属性对应长宽高 &lt;cylinder&gt; 圆柱体radius对应半径length对应高度 &lt;sphere&gt; 球体radius对应半径 &lt;mesh&gt; 外部文件引入filename设置外部文件scale设置缩放比例 &lt;material&gt;（可选） 纹理外观 name 名称 &lt;color&gt; 颜色rgba设置颜色值，取值[0, 1] &lt;texture&gt; 外部文件引入filename设置外部文件 例子长方体123456789&lt;robot name=&quot;my_box&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;1 2 3&quot; /&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/visual&gt;&lt;/robot&gt; 创建了一个简单的长方体，长宽高分别为1、2、3。 圆柱123456789&lt;robot name=&quot;my_cylinder&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;cylinder length=&quot;1&quot; radius=&quot;0.5&quot; /&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/visual&gt;&lt;/robot&gt; 创建了一个简单的圆柱，长度为1，半径为0.5 球体123456789&lt;robot name=&quot;my_cylinder&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;sphere radius=&quot;0.5&quot; /&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/visual&gt;&lt;/robot&gt; 创建一个简单的球体，半径为0.5。 Mesh 加载自定义的文件123456789&lt;robot name=&quot;my_mesh&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;mesh filename=&quot;package://demo_urdf/meshes/bowl.dae&quot; /&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/link&gt;&lt;/robot&gt; 从文件中读取形状，使用package开头，一般将对应的纹理文件dae放在文件夹meshes中。 位置和姿势12345678910&lt;robot name=&quot;my_box&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;origin xyz=&quot;0.1 0.2 0.3&quot; rpy=&quot;1.57 1.57 1.57&quot;&gt;&lt;/origin&gt; &lt;geometry&gt; &lt;box size=&quot;1 2 3&quot; /&gt; &lt;/geometry&gt; &lt;/visual&gt; &lt;/visual&gt;&lt;/robot&gt; 使用origin的xyz控制位置，rpy控制姿态，旋转遵循右手螺旋法则 设置视觉纹理 内部设置的方式 123456789101112&lt;robot name=&quot;my_box&quot;&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;1 2 3&quot; /&gt; &lt;/geometry&gt; &lt;material name=&quot;red&quot;&gt; &lt;color rgba=&quot;1.0 0 0 1.0&quot; /&gt; &lt;/material&gt; &lt;/visual&gt; &lt;/link&gt;&lt;/robot&gt; 外部设置的方式 1234567891011121314&lt;robot name=&quot;my_box&quot;&gt; &lt;material name=&quot;red&quot;&gt; &lt;color rgba=&quot;1.0 0 0 1.0&quot; /&gt; &lt;/material&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;1 2 3&quot; /&gt; &lt;/geometry&gt; &lt;material name=&quot;red&quot; /&gt; &lt;/visual&gt; &lt;/link&gt;&lt;/robot&gt; 建议使用第二种方式，因为一个颜色很有可能在多个地方需要使用。 joint各标签 子标签或属性（带&lt;&gt;为标签，不带为属性） 子标签和属性 描述 是否理解 name（必填） 用于描述joint的名称 √ type（必填） 用于描述joint的类型：1. fixed：固定关节2. revolute：限制旋转关节3. continuous：无限旋转关节4. prismatic：滑动关节5. floating：悬浮关节6. planar：2T1R √ &lt;origin&gt;（可选） 位置和姿态 √ xyz（可选） x、y、z的偏移，以米为单位。 √ rpy（可选） x、y、z的旋转，以弧度为单位 √ &lt;parent&gt;（必填） 被连接的那个link √ link link的名称 √ &lt;child&gt;（必填） 连接的link √ link link的名称 √ &lt;axis&gt;（可选） 指定的关节轴 √ xyz（必填） x、y、z 偏移或旋转 √ &lt;calibration&gt;（可选） 校准位置 rising（可选） 上升沿 falling（可选） 下降沿 &lt;dynamics&gt;（可选） 动力 damping（可选） 物理阻尼 friction（可选） 物理静摩擦力 &lt;limit&gt;(可选，revolute和prismatic必填) 限制约束 √ lower（可选） 下限 √ upper（可选） 上限 √ effort（必填） 最大承受力 √ velocity（必填） 最大速度 √ &lt;mimic&gt;（可选） 模拟现有一个关节value = multi * joint + offset joint（必填） 要模拟的关节 multiplier（可选） 乘法因子 offset（可选） 偏移量 &lt;safety_controller&gt;（可选） 安全控制器 soft_lower_limit（可选） 限制关节位置的下关节边界 soft_upper_limit（可选） 限制关节位置的上关节边界 k_position（可选） k_velocity（必填） 例子 在上面的表格中共有六种类型，实际使用中只有4中能使用，fixed、revolute、continuous、prismatic。 以下都定义了两个link，从而展示例子，只写关节部分代码 以下为公共区域代码，...表示加入后面的关节代码 12345678910111213141516171819202122232425262728&lt;robot name=&quot;my_box&quot;&gt; &lt;material name=&quot;red&quot;&gt; &lt;color rgba=&quot;1.0 0 0 1.0&quot;/&gt; &lt;/material&gt; &lt;material name=&quot;green&quot;&gt; &lt;color rgba=&quot;0 1.0 0 1.0&quot;/&gt; &lt;/material&gt; &lt;link name=&quot;base_link&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;0.1 0.2 1&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;red&quot;/&gt; &lt;/visual&gt; &lt;/link&gt; &lt;link name=&quot;link1&quot;&gt; &lt;visual&gt; &lt;geometry&gt; &lt;box size=&quot;0.1 0.2 1&quot;/&gt; &lt;/geometry&gt; &lt;material name=&quot;green&quot;/&gt; &lt;/visual&gt; &lt;/link&gt; ... &lt;/robot&gt; 关节1的名字为base_link，颜色为红色 关节2的名字为link1，颜色为绿色 fixed关节12345&lt;joint name=&quot;joint0&quot; type=&quot;fixed&quot;&gt; &lt;origin xyz=&quot;0 0 1&quot; rpy=&quot;0 0 0&quot; /&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;link1&quot;/&gt;&lt;/joint&gt; 该关节仅仅起到连接作用 revolute 关节1234567&lt;joint name=&quot;joint0&quot; type=&quot;revolute&quot;&gt; &lt;origin xyz=&quot;0 0 1&quot; rpy=&quot;0 0 0&quot;/&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;link1&quot;/&gt; &lt;limit effort=&quot;30&quot; velocity=&quot;1.0&quot; lower=&quot;-3.14&quot; upper=&quot;3.14&quot; /&gt;&lt;/joint&gt; 旋转关节，必须要加上限制约束，因为该关节有限制条件。 continuous 关节12345&lt;joint name=&quot;joint0&quot; type=&quot;continuous&quot;&gt; &lt;origin xyz=&quot;0 0 1&quot; rpy=&quot;0 0 0&quot;/&gt; &lt;parent link=&quot;base_link&quot;/&gt; &lt;child link=&quot;link1&quot;/&gt;&lt;/joint&gt; 旋转关节，没有限制约束，无限旋转 prismatic 关节 ​ - 平移关节，必须加限制约束。 总结如果需要多自由度，可以加入多关节，必须说6自由度，可以加3个旋转和3个平移，分别对应x、y、z三个不同的方向即可。 launch 启动文件123456789101112&lt;launch&gt; &lt;arg name=&quot;model&quot; default=&quot;geometry_box.urdf&quot;/&gt; &lt;arg name=&quot;gui&quot; default=&quot;true&quot; /&gt; &lt;arg name=&quot;rvizconfig&quot; default=&quot;$(find demo_urdf)/rviz/urdf.rviz&quot; /&gt; &lt;param name=&quot;robot_description&quot; command=&quot;$(find xacro)/xacro --inorder $(find demo_urdf)/urdf/$(arg model)&quot; /&gt; &lt;param name=&quot;use_gui&quot; value=&quot;$(arg gui)&quot;/&gt; &lt;node name=&quot;joint_state_publisher&quot; pkg=&quot;joint_state_publisher&quot; type=&quot;joint_state_publisher&quot; /&gt; &lt;node name=&quot;robot_state_publisher&quot; pkg=&quot;robot_state_publisher&quot; type=&quot;state_publisher&quot; /&gt; &lt;node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(arg rvizconfig)&quot; required=&quot;true&quot; /&gt;&lt;/launch&gt; arg：大致相当于设置变量 find：查找package","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"roslaunch","slug":"roslaunch","permalink":"https://askeynil.github.io/tags/roslaunch/"},{"name":"URDF","slug":"URDF","permalink":"https://askeynil.github.io/tags/URDF/"}]},{"title":"OpenCV 和 ROS 一起使用的一些坑","slug":"OpenCV 和 ROS 一起使用的一些坑","date":"2019-11-06T12:00:00.000Z","updated":"2019-11-07T00:00:00.000Z","comments":true,"path":"2019/e4bbffed.html","link":"","permalink":"https://askeynil.github.io/2019/e4bbffed.html","excerpt":"单独使用OpenCV的时候遇到了之前因为安装 ROS 而导致的一些坑点。 故记录下来。 问题描述 使用了 Anaconda 的虚拟环境，并且确认已经安装过 OpenCV 运行 Python，直接 xxx（不可描述）。 1234Traceback (most recent call last): File &quot;&#x2F;home&#x2F;askeynil&#x2F;Desktop&#x2F;cv&#x2F;class&#x2F;1. demo.py&quot;, line 1, in &lt;module&gt; import cv2 as cvImportError: &#x2F;opt&#x2F;ros&#x2F;kinetic&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cv2.so: undefined symbol: PyCObject_Type","text":"单独使用OpenCV的时候遇到了之前因为安装 ROS 而导致的一些坑点。 故记录下来。 问题描述 使用了 Anaconda 的虚拟环境，并且确认已经安装过 OpenCV 运行 Python，直接 xxx（不可描述）。 1234Traceback (most recent call last): File &quot;&#x2F;home&#x2F;askeynil&#x2F;Desktop&#x2F;cv&#x2F;class&#x2F;1. demo.py&quot;, line 1, in &lt;module&gt; import cv2 as cvImportError: &#x2F;opt&#x2F;ros&#x2F;kinetic&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;cv2.so: undefined symbol: PyCObject_Type 若只想看解决办法，请直接点我 问题研究 查看问题 12# 错误信息ImportError: /opt/ros/kinetic/lib/python2.7/dist-packages/cv2.so: undefined symbol: PyCObject_Type 很明显，ROS 在干坏事。 可是明明用了 Anaconda 的虚拟环境，为何会引用ROS的库，而且使用的是Python3为何会使用Python2.7里面的库。 回想ROS干过啥 在 ~/.zshrc 中添加了一句话 source /opt/ros/kinetic/setup.zsh （我使用的是 zsh ，如果使用bash，应该是在 ~/.bashrc 中添加了 source /opt/ros/kinetic/setup.bash ，一个道理） 然后又是 Python 找库找的不对，这时候应该想到 PYTHONPATH 环境变量 解释一下， PYTHONPATH 环境变量就是 Python 去 import 的时候的搜索路径。 首先打印一下当前的 PYTHONPATH 123echo $PYTHONPATH# 结果如下# /opt/ros/kinetic/lib/python2.7/dist-packages 果然，ROS就没干好事。。 解决方法 123# 1. 在 ~/.zshrc 或 ~/.bashrc 中将 PYTHONPATH 置为空PYTHONPATH=# 2. 或者果断点，将 source /opt/ros/kinetic/setup.zsh 或 source /opt/ros/kinetic/setup.bash 删掉 因为我还想着使用 ROS，所以我采用了方式1，因为用了方式2，ROS肯定就用不了啦。 问题再现 使用 roscore ，出现了问题。 提示如下 1234Traceback (most recent call last): File &quot;/opt/ros/kinetic/bin/roscore&quot;, line 36, in &lt;module&gt; from rosmaster.master_api import NUM_WORKERSImportError: No module named rosmaster.master_api 问题再探 好吧，这会轮到找不到 ROS 的依赖库了。 这可咋办，我作为一个懒人代表，不想每次使用都去注释一下。 ROS 需要自己的依赖库，也就是 /opt/ros/kinetic/lib/python2.7/dist-packages 这里面的东西。 解决办法很简单，只要在 roscore 之前将它加上就行。 起初想法是写一个脚本，然后取添加 source ，感觉过于麻烦。 然后想到大名鼎鼎的 alias 命令。 然后便有了以下的解决办法。 在 ~/.zshrc 或 ~/.bashrc 中添加如下命令： 1alias roscore=&#x27;source /opt/ros/kinetic/setup.zsh;roscore&#x27; 此后，roscore 的使用毫无问题了。 但是，新建一个终端的时候，我不可能再一次 roscore 吧，我要使用 rosrun 或者 catkin_make 怎么办？ 那就都加上就好了，所以命令变成了如下的三句话： 123alias roscore=&#x27;source /opt/ros/kinetic/setup.zsh;roscore&#x27; alias catkin_make=&#x27;source /opt/ros/kinetic/setup.zsh;catkin_make&#x27;alias rosrun=&#x27;source /opt/ros/kinetic/setup.zsh;rosrun&#x27; 大功告成。 最后，突然想到，在日常使用的时候，经常需要在 catkin_make 之后使用 source devel/setup.zsh 懒人做到底。。然后就又改成了如下三句话： 123alias roscore=&#x27;source /opt/ros/kinetic/setup.zsh;roscore&#x27; alias catkin_make=&#x27;source /opt/ros/kinetic/setup.zsh;catkin_make;source devel/setup.zsh&#x27;alias rosrun=&#x27;source /opt/ros/kinetic/setup.zsh;rosrun&#x27; 问题又现catkin_make --help异常 解决办法： 删掉 alias catkin_make=&#39;source /opt/ros/kinetic/setup.zsh;catkin_make;source devel/setup.zsh&#39; 中的 ;source devel/setup.zsh 总结： 还是不能太偷懒啊。。。 rosrun 一直出现找不到 package 查看 PYTHONPATH 发现 rosrun 之后只有一个 PYTHONPATH 发现 source /opt/ros/kinetic/setup.zsh 会将当前工作工作空间的 PYTHONPATH 环境给删除掉，ROS很傻吊 解决办法： 删掉原本的 alias rosrun 更改命令为： 123alias rosrun=&#x27;echo $PYTHONPATH | grep -q &quot;ros&quot; || source /opt/ros/kinetic/setup.bash;rosrun&#x27;# 为了以防万一，添加下面这句话alias rossource=&#x27;source /opt/ros/kinetic/setup.zsh&#x27; 总结ROS 和 OpenCV 的坑使用以下方式就可以完美解决 删掉原本在 ~/.bashrc 或 ~/.zshrc 中的 source /opt/ros/kinetic/setup.bash 或 source /opt/ros/kinetic/setup.zsh 在 ~/.bashrc 或 ~/.zshrc 中添加如下代码：(注意选择对应版本) 1234567891011# zsh 版本alias roscore=&#x27;source /opt/ros/kinetic/setup.zsh;roscore&#x27; alias catkin_make=&#x27;echo $PYTHONPATH | grep -q &quot;ros&quot; || source /opt/ros/kinetic/setup.zsh;catkin_make&#x27;alias rosrun=&#x27;echo $PYTHONPATH | grep -q &quot;ros&quot; || source /opt/ros/kinetic/setup.zsh;rosrun&#x27;alias rossource=&#x27;source /opt/ros/kinetic/setup.zsh&#x27;# bash 版本alias roscore=&#x27;source /opt/ros/kinetic/setup.bash;roscore&#x27; alias catkin_make=&#x27;echo $PYTHONPATH | grep -q &quot;ros&quot; || source /opt/ros/kinetic/setup.bash;catkin_make&#x27;alias rosrun=&#x27;echo $PYTHONPATH | grep -q &quot;ros&quot; || source /opt/ros/kinetic/setup.bash;rosrun&#x27;alias rossource=&#x27;source /opt/ros/kinetic/setup.bash&#x27; 万事大吉，重启终端！","categories":[{"name":"BugFix","slug":"BugFix","permalink":"https://askeynil.github.io/categories/BugFix/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://askeynil.github.io/tags/Anaconda/"}]},{"title":"OpenCV 之特征匹配","slug":"OpenCV 之特征匹配","date":"2019-11-06T08:00:00.000Z","updated":"2019-11-06T08:00:00.000Z","comments":true,"path":"2019/b1861ead.html","link":"","permalink":"https://askeynil.github.io/2019/b1861ead.html","excerpt":"本文所有代码，只使用C++实现，Python类似，甚至更加简单，暂不做实现。 特征检测特征检测常用的算法有: SIFT（尺度不变特征变换） SURF（加速鲁棒特征） ORB SIFT和SURF已经申请了专利，在OpenCV中使用需要付费，所以不做讨论。","text":"本文所有代码，只使用C++实现，Python类似，甚至更加简单，暂不做实现。 特征检测特征检测常用的算法有: SIFT（尺度不变特征变换） SURF（加速鲁棒特征） ORB SIFT和SURF已经申请了专利，在OpenCV中使用需要付费，所以不做讨论。 以下为ORB的基本用法： 12345678910111213141516171819202122Mat src = imread(&quot;./img/blox.jpg&quot;), gray;cvtColor(src, gray, COLOR_BGR2GRAY);// 创建 orb 检测器auto orb = ORB::create();// 使用 orb 查找特征点vector&lt;KeyPoint&gt; keyPoints;orb-&gt;detect(gray, keyPoints);// 使用 orb 计算描述符Mat desc;orb-&gt;compute(gray, keyPoints, desc);// 查找特征点和计算描述符也可以归为一步// orb-&gt;detectAndCompute(src, Mat(), keyPoints, desc);// 绘制特征点drawKeypoints(src, keyPoints, src);imshow(&quot;src&quot;, src);waitKey();destroyAllWindows(); 以上几乎为固定写法，如果是多图，detect和compute可以传多个数据进行匹配。得到多个keyPoints和desc 特征匹配之BFMatcher Brute-Force Matcher（BF Matcher）可以翻译成野蛮匹配器，它的步骤是先选取第一个图片特征集合的一个特征描述符，然后匹配另一个集合的所有特征，通过一些距离算法得到一个最近的距离distance。 查找特征点和描述符12345678910111213Mat img1 = imread(&quot;./img/box.png&quot;), gray1;Mat img2 = imread(&quot;./img/box_in_scene.png&quot;), gray2;cvtColor(img1, gray1, COLOR_BGR2GRAY);cvtColor(img2, gray2, COLOR_BGR2GRAY);// 创建 orb 检测器auto orb = ORB::create();// 使用 orb 查找特征点和计算描述符vector&lt;KeyPoint&gt; keyPoints1, keyPoints2;Mat desc1, desc2;orb-&gt;detectAndCompute(img1, Mat(), keyPoints1, desc1);orb-&gt;detectAndCompute(img2, Mat(), keyPoints2, desc2); 创建并使用BFMatcher123456789101112131415161718192021222324252627282930 // 创建 BFMatcher，开启crossCheck获取更精确的结果auto matcher = BFMatcher::create(NORM_HAMMING, true);// BFMatcher::create 函数需要两个参数，第一个是normType，第二个为crossCheck// 1. normType// 指定距离测量的规则，默认值是NORM_L2，该值一般与NORM_L1用在SIFT和SURF检测中。// 如果我们使用ORB检测，我们需要将该值设置为 NORM_HAMMING2。// 2. crossCheck// 交叉检查，默认为 false，设置该值为 true 来获取更精确的结果。// 对比两张图的特征，进行匹配vector&lt;DMatch&gt; matches;matcher-&gt;match(desc1, desc2, matches);// 根据评分排序，从小到大，因为越小越精确sort(matches.begin(), matches.end());// 移除较差的匹配结果，只保留前百分之15的结果double percent = 0.15;int num = matches.size() * percent;// 至少保留十个结果num = max(num, 10);// 对 matches 进行裁剪matches.assign(matches.begin(), matches.begin() + num);// 绘制图形Mat dst;drawMatches(img1, keyPoints1, img2, keyPoints2, matches, dst);// 绘制图形的时候，可以将最后一个参数，flags// 设置为 DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS 从而只显示匹配成功的点。 DMatch类的一些参数 distance：描述符之间的距离，值越小越好 trainIdx：描述符在train图片中的索引 queryIdx：描述符在query图片中的索引 imgIdx：train图片的索引 特征匹配之FLANN FLANN是Fast Library for Approximate Nearest Neighbors.的缩写。快速近似最近邻搜索库。 它包含一组算法，这些算法针对大型数据集中的快速最近邻搜索和高维特征进行了优化。对于大型数据集，它的运行速度比BFMatcher更快。 查找特征点和描述符12345678910111213Mat img1 = imread(&quot;./img/box.png&quot;), gray1;Mat img2 = imread(&quot;./img/box_in_scene.png&quot;), gray2;cvtColor(img1, gray1, COLOR_BGR2GRAY);cvtColor(img2, gray2, COLOR_BGR2GRAY);// 创建 orb 检测器auto orb = ORB::create();// 使用 orb 查找特征点和计算描述符vector&lt;KeyPoint&gt; keyPoints1, keyPoints2;Mat desc1, desc2;orb-&gt;detectAndCompute(img1, Mat(), keyPoints1, desc1);orb-&gt;detectAndCompute(img2, Mat(), keyPoints2, desc2); 创建并使用FLANN123456789101112131415161718192021222324252627// 创建 indexPar 和 searchPar// 当前使用 ORB 检测器，indexPar 使用LshIndexParams 参数默认给6,12，1auto indexPar = makePtr&lt;flann::LshIndexParams&gt;(6, 12, 1);// 检索参数，数值越大越准确，但是也越耗时auto searchPar = makePtr&lt;flann::SearchParams&gt;(100);// 使用 indexpar 和 searchPar 创建 flannMatcherFlannBasedMatcher flannMatcher(indexPar, searchPar);vector&lt;vector&lt;DMatch&gt;&gt; matches;vector&lt;vector&lt;char&gt;&gt; matchesMask;// 本例子使用 knnMatch， k 设置为 2flannMatcher.knnMatch(desc1, desc2, matches, 2);for (int i = 0; i &lt; matches.size(); i++) &#123; DMatch first = matches[i][0], last = matches[i][1]; // 第一个小于第二个的百分之80，舍去该值。这个比例根据不同的图片要进行一些微调。 if (first.distance &lt; 0.8 * last.distance) &#123; matchesMask.push_back(&#123;1, 0&#125;); &#125; else &#123; matchesMask.push_back(&#123;0, 0&#125;); &#125;&#125;Mat dst;// 使用 Mask 掩码来输出图像drawMatches(img1, keyPoints1, img2, keyPoints2, matches, dst, Scalar::all(-1), Scalar::all(-1), matchesMask, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"}]},{"title":"OpenCV 之角点检测","slug":"OpenCV 之角点检测","date":"2019-11-04T02:00:00.000Z","updated":"2019-11-04T02:00:00.000Z","comments":true,"path":"2019/b202f100.html","link":"","permalink":"https://askeynil.github.io/2019/b202f100.html","excerpt":"哈里斯角点检测 克里斯·哈里斯（Chris Harris）和迈克·史蒂芬斯（Mike Stephens）在1988年的论文《组合式拐角和边缘检测器》（《A Combined Corner and Edge Detector》）中做了一次找到这些拐角的尝试，所以现在将其称为哈里斯拐角检测器。这篇论文把这个简单的想法变成了数学形式。它基本上找到了在所有方向上位移的强度差异。 官方api解释直达 1cornerHarris(src, dst, blockSize, ksize, k) src：必须是单通道灰度图 dst：返回类型是CV_32FC1，大小与 src 相同。 blockSize：角点检测考虑的领域大小，int类型 kszie：Sobel算子的大小，int类型 k：自由度参数，值越小检测出的结果越多。double类型","text":"哈里斯角点检测 克里斯·哈里斯（Chris Harris）和迈克·史蒂芬斯（Mike Stephens）在1988年的论文《组合式拐角和边缘检测器》（《A Combined Corner and Edge Detector》）中做了一次找到这些拐角的尝试，所以现在将其称为哈里斯拐角检测器。这篇论文把这个简单的想法变成了数学形式。它基本上找到了在所有方向上位移的强度差异。 官方api解释直达 1cornerHarris(src, dst, blockSize, ksize, k) src：必须是单通道灰度图 dst：返回类型是CV_32FC1，大小与 src 相同。 blockSize：角点检测考虑的领域大小，int类型 kszie：Sobel算子的大小，int类型 k：自由度参数，值越小检测出的结果越多。double类型 12345678910111213Mat gray, points;cvtColor(src, gray, COLOR_BGR2GRAY);cornerHarris(gray, points, 2, 3, 0.04);double points_max;src.copyTo(dst);minMaxLoc(points, nullptr, &amp;points_max);for (int i = 0; i &lt; dst.size().height; i++) &#123; for (int j = 0; j &lt; dst.size().width; j++) &#123; if (points.at&lt;float&gt;(i, j) &gt; 0.01 * points_max) &#123; dst.at&lt;Vec3b&gt;(i, j) = &#123;0, 0, 255&#125;; &#125; &#125;&#125; 史-托马斯角点检测 J. Shi 和 C. Tomasi 在其论文 《Good Features to Track》 中对其进行了小的修改，与Harris Corner Detector相比，该方法表现出出更好的结果。 官方api解释直达 1goodFeaturesToTrack(src, corners, maxCorners, qualityLevel, minDistance) src：8位单通道或者32位浮点单通道图像 corners：检测到的角的点集，类型为vector&lt;Point&gt; maxCorners：最大角数 qualityLevel：最低接收的质量百分比 minDistance：点之间的最小距离 12345678Mat gray;vector&lt;Point&gt; points;src.copyTo(dst);cvtColor(src, gray, COLOR_BGR2GRAY);goodFeaturesToTrack(gray, points, 25, 0.01, 10);for (int i = 0; i &lt; points.size(); i++) &#123; circle(dst, points[i], 3, &#123;0, 0, 255&#125;, -1);&#125; 完整代码：https://github.com/AskeyNil/BlogCode/blob/master/OpenCV/cc/CornerDetector.cc","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"}]},{"title":"Shell 命令之查找","slug":"Shell 命令之查找","date":"2019-11-03T02:00:00.000Z","updated":"2019-11-03T02:00:00.000Z","comments":true,"path":"2019/fafe7b6d.html","link":"","permalink":"https://askeynil.github.io/2019/fafe7b6d.html","excerpt":"以下所有命令仅仅只做常见用法的介绍，不做详细的参数介绍 如需详细介绍，可到 https://man.linuxde.net 查阅 以下的显示结果均为使用 oh-my-zsh 的显示结果，如果是使用 bash 可能略有差异 注意：zsh 默认情况下不支持*通配符匹配，需要在~/.zshrc中添加setopt nonomatch即可。 which which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。 一般使用过程中直接使用which 命令即可： 例如： 12which python# /usr/bin/python","text":"以下所有命令仅仅只做常见用法的介绍，不做详细的参数介绍 如需详细介绍，可到 https://man.linuxde.net 查阅 以下的显示结果均为使用 oh-my-zsh 的显示结果，如果是使用 bash 可能略有差异 注意：zsh 默认情况下不支持*通配符匹配，需要在~/.zshrc中添加setopt nonomatch即可。 which which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。 一般使用过程中直接使用which 命令即可： 例如： 12which python# /usr/bin/python whereis whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径 whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 一般用来查找都在哪些目录 12where bash# bash: /bin/bash /etc/bash.bashrc /usr/share/man/man1/bash.1.gz grep grep是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 在文件中查找一个字符串（在 main.cc 中查找 binary） 12345678910grep &quot;binary&quot; main.cc# Mat binary; （注意：此时的binary会标红显示）# 如果是多个文件，后面添加文件名即可，在查找的位置前方会显示文件查找到文件的名称# 比如说grep &quot;binary&quot; main.cc demo.cc# 类似这样：（在我的 shell 中，前面的 main.cc 标为紫色，binary 标为红色）# main.cc: Mat binary;# 当然 shell 中的 * 语法在这里也是适用的，例如匹配所有以 cc 为后缀的文件grep &quot;binary&quot; *.cc 正则匹配（在main.cc中查找&quot;&quot;包裹起来的内容） 123# 正则匹配适用 -E 关键字grep -E &quot;\\&quot;.*\\&quot;&quot; main.cc# #include &quot;opencv2/opencv.hpp&quot; 只显示匹配到的部分 12345678# 参数 -ogrep -o &quot;binary&quot; main.cc# binary# 上面这种做法似乎没有意义，计数好像有点用处# 该参数可以用在正则匹配的时候，直接打印匹配出来的字符串，不需要显示其他的无关信息# 比如：grep -oE &quot;\\&quot;.*\\&quot;&quot; main.cc# &quot;opencv2/opencv.hpp&quot; 输出行号，统计行数 12345678# 输出行号 参数 -ngrep -nE &quot;\\&quot;.*\\&quot;&quot; main.cc# 在我的 shell 中 1 使用的是绿色数字显示，即行号用绿色数字显示# 1:#include &quot;opencv2/opencv.hpp&quot;# 统计行数 参数 -cgrep -cE &quot;\\&quot;.*\\&quot;&quot; main.cc# 8 忽略大小写匹配 123# 参数 -igrep -i &quot;BINARY&quot; main.cc# Mat binary; 只输出匹配到的文件名 1234# 参数 -lgrep -l &quot;binary&quot; *.cc# main.cc# ... 递归文件夹查找（在当前目录递归查找：”binary”） 1234567# 参数 -rgrep -r &quot;binary&quot; .# Mat binary;# ...# 此时可能会提示一些错误信息，比如当前文件夹下面有一个二进制文件等等，我们要忽略其错误信息# 忽略错误信息 参数 -s# 忽略二进制文件 参数 -I 匹配多个不同的字符串（查找 main.cc 文件中 binary 和 main 字符串） 12345# 1. 通过正则实现grep -E &quot;binary|main&quot; main.cc# 2. 通过参数 -e 实现grep -e &quot;binary&quot; -e &quot;main&quot; main.cc 包括和排除指定文件 12345678910# 一般我们可以是用 *.后缀 来包括指定文件，但是如果在递归操作的时候不足以支持我们的操作# 我们可以使用三个关键字来进行该操作# 1. --include 包含...文件grep -Ir &quot;binary&quot; . --include=*.cc# 如果是多个grep -Ir &quot;binary&quot; . --include=*.&#123;cc,cmake&#125;# 2. --exclude 排除...文件grep -Ir &quot;binary&quot; . --exclude=*.cmake# 3. --exclude-dir 排除...文件夹里的文件grep -Ir &quot;binary&quot; . --exclude-dir=build 静默输出（一般用来判断是否查找到） 123# 参数 -qgrep -q &quot;binary&quot; main.cc# 该参数一般用来条件测试，成功返回0，失败返回非0 整理归类 参数 解释 -E 正则匹配 -o 只显示匹配到的部分 -n 输出行号 -c 统计行数 -i 忽略大小写 -l 只输出匹配到的文件名 -r 递归查找 -s 忽略错误信息 -I 忽略二进制文件 -e 匹配多个字符串 --include 包含 … 文件（用等号连接后面的参数） --exclude 排除 … 文件（用等号连接后面的参数） --exclude-dir 排除 … 文件夹（用等号连接后面的参数） 颜色区别： 意义 颜色 匹配到的字符串 红色 匹配到的文件名 紫色 匹配到的行号 绿色 find find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 列出当前目录及子目录下所有文件和文件夹 1find . 在/home目录下查找以py为后缀的文件 123find /home -name &quot;*.py&quot;# 与 grep 一样使用可以使用参数 -i 来忽略大小写find /home -iname &quot;*.py&quot; 当前目录及子目录查找py和cc结尾的文件 1find . -name &quot;*.py&quot; -o -name &quot;*.cc&quot; 匹配路径字符串 12# 参数 -pathfind . -name &quot;*src*&quot; 正则文件匹配 1234# 参数 -regex find . -regex &quot;.*\\(py\\|cc\\)&quot;# 也可以使用 -i 进行忽略大小写find . -iregex &quot;.*\\(py\\|cc\\)&quot; 当前目录不是.py为后缀的文件 12# ! 否定匹配find . ! -name &quot;*.py&quot; 整理归类 参数 解释 -i 忽略大小写查找 -name 查找文件名称 -regex 正则查找 ! 否定匹配 locate/slocate locate命令和slocate命令都用来查找文件或目录。 locate命令其实是find -name的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库/var/lib/locatedb，这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 1locate &quot;*.cc&quot;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Shell","slug":"Coding/Shell","permalink":"https://askeynil.github.io/categories/Coding/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://askeynil.github.io/tags/Shell/"}]},{"title":"NumPy 之 mgrid、ogrid","slug":"NumPy之mgrid","date":"2019-11-02T14:00:00.000Z","updated":"2019-11-02T14:00:00.000Z","comments":true,"path":"2019/1df81ffb.html","link":"","permalink":"https://askeynil.github.io/2019/1df81ffb.html","excerpt":"mgrid 返回密集的多维”网格“实例 用法：np.mgrid[第1维, 第2维, 第3维...] 维度中的写法为a:b:c a，起始索引 b，结束索引 c，步长 如果为实数，表示间隔。区间为[a, b)，左闭右开。 如果为复数，表示个数。区间为[a, b]，左闭右闭。","text":"mgrid 返回密集的多维”网格“实例 用法：np.mgrid[第1维, 第2维, 第3维...] 维度中的写法为a:b:c a，起始索引 b，结束索引 c，步长 如果为实数，表示间隔。区间为[a, b)，左闭右开。 如果为复数，表示个数。区间为[a, b]，左闭右闭。 网格，顾名思义，就是创建对应点集，下面举例来说明这一点 创建一个一维的索引12np.mgrid[0:10]# [0 1 2 3 4 5 6 7 8 9] 一维跟arange()其实是一样的，这里就不做过多的介绍了 创建一个二维的索引123456789np.mgrid[0:3,0:3]# [[[0 0 0]# [1 1 1]# [2 2 2]]# # [[0 1 2]# [0 1 2]# [0 1 2]]] 其实就是创建了点集 (0, 0), (0, 1), (0, 2) (1, 0), (1, 1), (1, 2) (2, 0), (2, 1), (2, 2) 大概意思就是，第一维所有点映射到二维所有的点。就是所有的一维和二维能形成的全部的点 创建一个三维的索引123456789101112131415np.mgrid[0:2, 0:2, 0:2]# [[[[0 0]# [0 0]]# [[1 1]# [1 1]]]## [[[0 0]# [1 1]]# [[0 0]# [1 1]]]## [[[0 1]# [0 1]]# [[0 1]# [0 1]]]] 其实就是创建了点集 (0, 0, 0), (0, 0,1) (0, 1, 0), (0, 1,1) (1, 0, 0), (1, 0,1) (1, 1, 0), (1, 1,1) 一维，二维，三维能形成的所有的点 推到到N维 实质上就是创建N维所有能形成的点 需要注意的是：在所有的例子中没有使用复数的步长，但是要知道的是复数的步长代表将a,b形成的区域等分成若干份，取对应的值，跟实数的每个数相隔的距离不同。 ogrid 返回开放的多维”网格“的实例 该方法跟mgrid很类似，但不是形成所有的点，而是只形成对应的数据 一维12np.ogrid[0:10]# [0 1 2 3 4 5 6 7 8 9] 与上面的一样，没啥好说的。 二维1234np.ogrid[0:3, 0:3]# [array([[0],# [1],# [2]]), array([[0, 1, 2]])] 一共两维，有几维就有几个array，第一个的数据在第一维度，第二个的数据在第二维度，仅仅只有自己维度有数据，推理到多维是一样的。 所以，该方法一般用来创建离散点集或者是离散多个多维数组使用。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"NumPy","slug":"NumPy","permalink":"https://askeynil.github.io/tags/NumPy/"}]},{"title":"OpenCV 之硬币分割","slug":"OpenCV 之硬币分割","date":"2019-11-02T05:00:00.000Z","updated":"2019-11-02T12:00:00.000Z","comments":true,"path":"2019/bae2941.html","link":"","permalink":"https://askeynil.github.io/2019/bae2941.html","excerpt":"官方例程：https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_watershed/py_watershed.html?highlight=coins 简单描述 获取需要分割的图片 转化为灰度图 转化为二值图 转化为距离图 分离距离图，转化为二值图 查找距离二值图的轮廓 给二值图轮廓中的每个点进行颜色标记，从1开始标记 将标记的图转化为固定类型的标记图（CV_32S类型） 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓的数量加1。（非常重要，后面介绍） 使用分水岭算法将标记的图和原图关联起来。 给标记图中每块标记区域上色","text":"官方例程：https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_watershed/py_watershed.html?highlight=coins 简单描述 获取需要分割的图片 转化为灰度图 转化为二值图 转化为距离图 分离距离图，转化为二值图 查找距离二值图的轮廓 给二值图轮廓中的每个点进行颜色标记，从1开始标记 将标记的图转化为固定类型的标记图（CV_32S类型） 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓的数量加1。（非常重要，后面介绍） 使用分水岭算法将标记的图和原图关联起来。 给标记图中每块标记区域上色 话不多说，先贴代码 Python实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import cv2 as cvimport numpy as npdef findMarkers(distance_binary, binary, isSystem): if isSystem: # 6-8 步 使用 OpenCV 提供的函数替代 compCount, markers = cv.connectedComponents(distance_binary) # 9. 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓数量加 1 # 注: connectedComponents 函数的返回值就是轮廓数加1 markers[binary == 0] = compCount else: # 6. 查找距离二值图的轮廓 _, contours, _ = cv.findContours( distance_binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE) # 7. 给二值图轮廓中的每个点进行颜色标记，从 1 开始标记 compCount = len(contours) for index in range(compCount): cv.drawContours(distance_binary, contours, index, index+1, -1) # 8. 将标记的图转化为固定类型的标记图 markers = np.int32(distance_binary) # 9. 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓数量加 1 compCount += 1 markers[binary == 0] = compCount return compCount, markers # 1. 获取需要分割的图片src = cv.imread(&quot;./img/coins.jpg&quot;)cv.imshow(&quot;src&quot;, src)# 2. 转化为灰度图gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)cv.imshow(&quot;gray&quot;, gray)# 3. 转化为二值图_, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY_INV | cv.THRESH_OTSU)cv.imshow(&quot;binary&quot;, binary)# 4. 转化为距离图distance = cv.distanceTransform(binary, cv.DIST_L2, 3)# 将距离图标准化到 0,1 之间cv.normalize(distance, distance, 0, 1.0, cv.NORM_MINMAX)cv.imshow(&quot;distance&quot;, distance)# 5. 分离距离图, 转化为二值图_, distance_binary = cv.threshold(distance, 0.8, 255, cv.THRESH_BINARY)distance_binary = distance_binary.astype(np.uint8)cv.imshow(&quot;distance_binary&quot;, distance_binary)compCount, markers = findMarkers(distance_binary, binary, False)# 10. 使用分水岭算法注水cv.watershed(src, markers)# 11. 给注水之后的标记图上色for index in range(1, compCount+1): src[markers == index] = np.random.randint(0, 256, size=(1, 3))cv.imshow(&quot;water_later&quot;, src)while (True): s = cv.waitKey(100) if s == ord(&#x27;q&#x27;): breakcv.destroyAllWindows() C++ 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &quot;opencv2/opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;void findMarkers(const Mat &amp;distance_binary, const Mat &amp;binary, Mat &amp;markers, int &amp;compCount, bool isSystem) &#123; if (isSystem) &#123; // 6-8 步 使用 OpenCV 提供的函数替代 compCount = connectedComponents(distance_binary, markers); // 9. 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓数量加 1 // 注: connectedComponents 函数的返回值就是轮廓数加1 markers.setTo(compCount, 255 - binary); &#125; else &#123; // 6. 查找距离二值图的轮廓 vector&lt;vector&lt;Point&gt;&gt; contours; findContours(distance_binary, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE); compCount = contours.size(); // 7. 给二值图轮廓中的每个点进行颜色标记，从 1 开始标记 for (int i = 0; i &lt; compCount; i++) &#123; drawContours(distance_binary, contours, i, Scalar(i + 1), -1); &#125; // 8. 将标记的图转化为固定类型的标记图 distance_binary.convertTo(markers, CV_32S); // 9. 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓数量加 1 markers.setTo(++compCount, 255 - binary); &#125;&#125;int main() &#123; // 1. 获取需要分割的图片 Mat src = imread(&quot;./img/coins.jpg&quot;); imshow(&quot;src&quot;, src); // 2. 转化为灰度图 Mat gray; cvtColor(src, gray, COLOR_BGR2GRAY); imshow(&quot;gray&quot;, gray); // 3. 转化为二值图 Mat binary; threshold(gray, binary, 0, 255, THRESH_BINARY_INV | THRESH_OTSU); imshow(&quot;binary&quot;, binary); // 4. 转化为距离图 Mat distance; distanceTransform(binary, distance, DIST_L2, 3); // 将距离图标准化到 0, 1 之间 normalize(distance, distance, 0, 1, NORM_MINMAX); imshow(&quot;distance&quot;, distance); // 5.分离距离图,转化为二值 Mat distance_binary; threshold(distance, distance_binary, 0.8, 255, THRESH_BINARY); // 5.1 将distance_binary 转化到 CV_8U Mat distance_binary2; distance_binary.convertTo(distance_binary2, CV_8U); imshow(&quot;distance_binary&quot;, distance_binary2); // 6-9 步 Mat markers; int compCount; findMarkers(distance_binary2, binary, markers, compCount, true); // 10. 使用分水岭算法注水 watershed(src, markers); // 11. 给注水后的标记图上色 vector&lt;Vec3b&gt; colorTab; RNG rng; for (int i = 0; i &lt; compCount; i++) &#123; int g = rng.uniform(0, 255); int b = rng.uniform(0, 255); int r = rng.uniform(0, 255); colorTab.emplace_back(g, b, r); &#125; for (int i = 0; i &lt; markers.rows; i++) for (int j = 0; j &lt; markers.cols; j++) &#123; int index = markers.at&lt;int&gt;(i, j); if (index &lt;= 0 || index &gt; compCount) src.at&lt;Vec3b&gt;(i, j) = Vec3b(0, 0, 0); else src.at&lt;Vec3b&gt;(i, j) = colorTab[index - 1]; &#125; imshow(&quot;water_later&quot;, src); waitKey(); destroyAllWindows();&#125; 最终显示结果 这里仅仅使用 Python 版代码的截图，C++版运行结果是一样的。 思路分析在分水岭算法中，我们要找到分割次数，就是要找到标记点，即Markers。 在本例中使用距离变换算法统计出硬币的个数，即24个，使用距离变换后的二值图，可以很好的打出24个标记，标记每一个硬币。但是我们还需要将背景屏蔽掉，即将不是硬币的地方打一个标记，不然使用分水岭算法的时候水会漫出去导致未找到正确的边界。 思路分析清晰，最后剩下的就是怎么打标记的问题了？ 两种解决办法： 查找轮廓 使用系统的connectedComponents的函数 用轮廓查找来打标记 仅使用 Python 代码来分析逻辑，C++ 同理 再贴一遍代码 123456789101112131415# 6. 查找距离二值图的轮廓_, contours, _ = cv.findContours( distance_binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)# 7. 给二值图轮廓中的每个点进行颜色标记，从 1 开始标记compCount = len(contours)for index in range(compCount): cv.drawContours(distance_binary, contours, index, index+1, -1)# 8. 将标记的图转化为固定类型的标记图markers = np.int32(distance_binary)# 9. 在标记图中将二值图黑色的区域对应的位置设置标记为轮廓数量加 1compCount += 1markers[binary == 0] = compCount 因为图片已经是距离变换后的二值化的图了，所以能查找到准确的轮廓。 查找到轮廓后，给每个轮廓填充不一样的颜色即可（本质就是标记，好让分水岭算法去计算边界） 背景也要打上一个标记（这步很重要，不然会粘连起来） 使用connectedComponents来打标记1connectedComponents(image, markers) image：要标记的8位单通道的图 markers：输出的标记图 该方法在C++中有一个返回值，返回值的代表了标记的个数N 该方法在Python中有两个返回值，第一个代表标记的个数N和输出的标记图Markers 该方法要注意的是：标签总数为[0, N-1]，0表示背景标签，即image为0的那部分。后面还需做特定的处理。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"分水岭算法","slug":"分水岭算法","permalink":"https://askeynil.github.io/tags/%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95/"},{"name":"边缘检测","slug":"边缘检测","permalink":"https://askeynil.github.io/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"},{"name":"轮廓提取","slug":"轮廓提取","permalink":"https://askeynil.github.io/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"}]},{"title":"OpenCV 常用方法整理","slug":"OpenCV 常用方法整理","date":"2019-11-02T02:00:00.000Z","updated":"2019-11-02T03:00:00.000Z","comments":true,"path":"2019/144d9f9d.html","link":"","permalink":"https://askeynil.github.io/2019/144d9f9d.html","excerpt":"以下只列举常用的方法和常用的参数，例如枚举，只会将最常用的几个列举出来，详细的请参考官方文档。 对于C++默认使用了using namespace cv; 对于Python默认使用了import cv2 as cv 和 import numpy as np OpenCV版本：3.4.7 读取图片1imread(filename, flags) filename：图片路径 flags： IMREAD_COLOR：默认值，返回3通道的BGR色彩图像 IMREAD_GRAYSCALE：返回单通道灰色图片 IMREAD_UNCHANGED：按原样返回。","text":"以下只列举常用的方法和常用的参数，例如枚举，只会将最常用的几个列举出来，详细的请参考官方文档。 对于C++默认使用了using namespace cv; 对于Python默认使用了import cv2 as cv 和 import numpy as np OpenCV版本：3.4.7 读取图片1imread(filename, flags) filename：图片路径 flags： IMREAD_COLOR：默认值，返回3通道的BGR色彩图像 IMREAD_GRAYSCALE：返回单通道灰色图片 IMREAD_UNCHANGED：按原样返回。 C++ 1Mat src = imread(&quot;1.jpg&quot;, IMREAD_UNCHANGED); 对于C++来说，imread的返回值为Mat类，该类是OpenCV的自建类 Python 1src = cv.imread(&quot;1.jpg&quot;, cv.IMREAD_UNCHANGED) 对于Python来说，imread的返回值为NumPy.ndarray 对于图像矩阵，C++都是自建的Mat类，而Python则是numpy.ndarray。后面不在赘述这个问题。 保存图片1imwrite(filename, img) filename：图片要保存的路径 img：图像矩阵 比较简单，不做详细介绍。 该方法还有一个参数，可以参数编码，详细点击imwrite 显示图片1show(winname, src) winname：窗口的名称 src：显示的图片矩阵 图片缩放图片缩放常见算法有： 最近领域插值法 双线性插值法 双三次插值法 OpenCV官方提供的resize()的函数（默认为双线性插值法）： 1resize(src, dst, dsize, fx, fy, interpolation) src要缩放的图片 dst输出的图像 dsize输出图像的大小 C++：Size类 Python：元组，前面为width，后面为height fx：沿水平轴的比例因子 当它等于 0 时，计算为 dsize.width / src.cols fy：沿垂直轴的比例因子 当它等于 0 时，计算为 dsize.height / src.rows interpolation：缩放用的方法 INTER_NEAREST：最近邻域插值法 INTER_LINEAR：双线性插值法 INTER_CUBIC：双三次插值法 C++ 12Mat dst;resize(src, dst, Size(100, 100)); Python 1dst = cv.resize(src, (100, 100), interpolation=cv.INTER_NEAREST) 图像操作仿射变换矩阵的缩放、旋转、位移都可以使用矩阵变换来实现 缩放矩阵：$$\\begin{bmatrix}k_x &amp; 0 &amp; 0 \\0 &amp; k_y &amp; 0\\end{bmatrix}$$旋转矩阵：$$\\begin{bmatrix}cos\\theta &amp; -sin\\theta &amp; 0 \\sin\\theta &amp; cos\\theta &amp; 0\\end{bmatrix}$$位移：$$\\begin{bmatrix}1 &amp; 0 &amp; t_x \\0 &amp; 1 &amp; t_y\\end{bmatrix}$$仿射变换的函数： 1warpAffine(src, dst, M, dsize) src：输入的图像 dst：输出的图像 M：（2 x 3）的转换矩阵 dsize：输出图像的尺寸 获取旋转矩阵的方法： 1getRotationMatrix2D(center, angle, scale) center：旋转中心 c++：类型为Point2f Python：类型为元组，两个元素，分别是x，y。 angle：旋转角度，单位为度，正值表示逆时针旋转。 scale：缩放比例 C++ 1234567891011121314151617181920// 平移矩阵Mat translation_matrix = (Mat_&lt;float&gt;(2, 3) &lt;&lt; 1, 0, 1, 0, 1, 1);// 缩放矩阵Mat scale_matrix = (Mat_&lt;float&gt;(2, 3) &lt;&lt; 2, 0, 0, 0, 2, 0);// 旋转矩阵Mat rotated_matrix = getRotationMatrix2D( Point2f(src.size().width / 2, src.size().height / 2), 45, 0.5);// 获取对应的图形Mat dst;// 平移// warpAffine(src, dst, translation_matrix, src.size());// 缩放// warpAffine(src, dst, scale_matrix, src.size());// 旋转// warpAffine(src, dst, rotated_matrix, src.size());// imshow(&quot;dst&quot;, dst); Python 12345678910111213141516171819202122232425# 获取图像的高和宽height, width = src.shape[0:2]# 平移矩阵translation_matrix = np.float32([[1, 0, 1], [0, 1, 1]])# 缩放矩阵scale_matrix = np.float32([[2, 0, 0], [0, 2, 0]])# 旋转矩阵rotated_matrix = cv.getRotationMatrix2D((width/2, height/2), 45, 0.5)# 平移# dst = cv.warpAffine(src, translation_matrix, src.shape[1::-1])# 缩放# dst = cv.warpAffine(src, scale_matrix, src.shape[1::-1])# 旋转# dst = cv.warpAffine(src, rotated_matrix, src.shape[1::-1])# 解释一下src.shape[1::-1]# 在src.shape中，第一个值代表height，第二个代表width# 在 warpAffine 参数中 dsize, 第一个表示width, 第二个表示height# 综上，将其反过来即可# cv.imshow(&quot;dst&quot;, dst) 透视变换透视变换（Perspective Transformation)是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。 透视变换的函数： 1warp(src, dst, M, dsize) src：输入的图像 dst：输出的图像 M：（3 x 3）转换矩阵 dsize：输出图像的尺寸 获取透视变换需要的矩阵 1getPerspectiveTransform(src, dst) src：原图中四边形顶点的坐标 C++：类型为vector&lt;Point2f&gt; Python：类型为numpy.ndarray ，dtype为numpy.float32 dst：目标图像中的对应四个点的坐标，类型同上。 C++ 123456789// 这里仅仅说明用法，参数根据实际情况，src_point和dst_point应该不一样才对vector&lt;Point2f&gt; src_point&#123;Point2i(0, 0), Point2i(0, 1), Point2i(1, 0), Point2i(1, 1)&#125;;vector&lt;Point2f&gt; dst_point&#123;Point2i(0, 0), Point2i(0, 1), Point2i(1, 0), Point2i(1, 1)&#125;;Mat matrix = getPerspectiveTransform(src_point, dst_point);Mat dst;warpPerspective(src, dst, matrix, src.size());imshow(&quot;dst&quot;, dst); Python 1234567# 同上src_point = np.float32(((0, 0), (0, 1), (1, 0), (1, 1)))dst_point = np.float32(((0, 0), (0, 1), (1, 0), (1, 1)))print(type(src_point))matrix = cv.getPerspectiveTransform(src_point, dst_point)dst = cv.warpPerspective(src, matrix, src.shape[1::-1])cv.imshow(&quot;dst&quot;, dst) 图像金字塔（上、下采样）上采样1pyrUp(src, dst) 下采样1pyrDown(src, dst) src：原图 dst：采样结果图 C++ 12345678Mat up_dst, down_dst;// 上采样pyrUp(src, up_dst);// 下采样pyrDown(src, down_dst);imshow(&quot;up_dst&quot;, up_dst);imshow(&quot;down_dst&quot;, down_dst); Python 1234567# 上采样up_dst = cv.pyrUp(src)# 下采样down_dst = cv.pyrDown(src)cv.imshow(&quot;up_dst&quot;, up_dst)cv.imshow(&quot;down_dst&quot;, down_dst) 图像融合1addWeighted(src1, alpha, src2, beta, gamma, dst) src1：图1 alpha：图1系数，double src2：图2 beta：图2系数，double gamma：添加的标量 dst：输出图像 C++ 123Mat dst;addWeighted(src, 0.5, src, 0.5, 100, dst);imshow(&quot;dst&quot;, dst); Python 12dst = cv.addWeighted(src, 0.5, src, 0.5, 100)cv.imshow(&quot;dst&quot;, dst) 绘制图形绘制线段1line(src, pt1, pt2, color, thickness, lineType) src：图片 pt1：起点 C++：Point类型 Python：元组类型 pt2：终止点，类型同上 color：颜色 C++：Scalar类型，GBR Python：颜色（GBR）元组 thickness：线宽，int，默认值为1 lineType：线类型 LINE_AA：抗锯齿线 LINE_8：8连线，默认值 C++ 1line(src, Point(100, 100), Point(200, 200), Scalar(0, 0, 255)); Python 1cv.line(src, (100, 100), (200, 200), (0, 0, 255)) 绘制矩形1rectangle(src, pt1, pt2, color, thickness, lineType) 参数同上，但是pt1和pt2一定是矩形的对角点。 注意：如果thickness为负数，则会使用color填充整个矩阵 C++ 1rectangle(src, Point(100, 100), Point(200, 200), Scalar(0, 0, 255)); Python 1cv.rectangle(src, (100, 100), (200, 200), (0, 0, 255)) 绘制圆1circle(src, center, radius, color, thickness, lineType) src：图片 center：圆的中点 C++：Point类型 Python：元组类型，(x, y) radius：半径，int color：颜色，同line thickness：线宽，同line lineType：线类型，同line C++ 1circle(src, Point(100, 100), 100, Scalar(0, 0, 255)) Python 1cv.circle(src, (100, 100), 100, (0, 0, 255)) 绘制多边形 该方法用于绘制多条多边形曲线 1polylines(src, pts, isClosed, color, thickness, lineType) 与上相同的参数不做解释（src、color、thickness、lineType） pts：顶点集合，二维数组，分别表示多边形数量，多边形的顶点位置 isClosed：是否闭合。如果闭合会从最后一个顶点到第一个顶点绘制一条直线。 C++ 1234vector&lt;vector&lt;Point&gt;&gt; pts&#123; &#123;Point(100, 100), Point(200, 200), Point(300, 400), Point(200, 100)&#125;&#125;;polylines(src, pts, false, Scalar(0, 0, 255));imshow(&quot;src&quot;, src); Python 123pts = np.array([[(100, 100), (200, 200), (300, 400), (200, 100)]])cv.polylines(src, pts, False, (0, 0, 255))cv.imshow(&quot;src&quot;, src) 绘制文字1putText(src, text, org, fontFace, fontScale, Color, lineType) 与上相同的参数不做介绍。 text：文字文本，string类型 org：文字左下角的坐标位置 C++：Point类型 Python：元组类型，(x, y) fontFace：字体名称。具体见HersheyFonts，注意：OpenCV默认不支持中文 fontScale：字体的缩放大小。 C++ 1putText(src, &quot;I&#x27;m a text&quot;, Point(100, 100), FONT_HERSHEY_PLAIN, 1, Scalar(0, 0, 255)); Python 1cv.putText(src, &quot;I&#x27;m a text&quot;, (100, 100), cv.FONT_HERSHEY_PLAIN, 1, (0, 0, 255) 转换颜色空间1cvtColor(src, dst, code) code：颜色空间转换代码 该方法我们常常用来将原图转换为灰色图和将GBR转换为HSV C++ 123Mat dst;cvtColor(src, dst, COLOR_BGR2GRAY);imshow(&quot;dst&quot;, dst); Python 12dst = cv.cvtColor(src, cv.COLOR_BGR2GRAY)cv.imshow(&quot;dst&quot;, dst) 直方图统计直方图1calcHist(images, channels, mask,hist,histSize, ranges) images：需要处理的图片数组 channels：计算对应图片的哪个通道 mask：蒙版 hist：输出的直方图数组 histSize：输出的直方图的大小 ranges：范围 C++ 123Mat hist;calcHist(vector&lt;Mat&gt;&#123;src&#125;, vector&lt;int&gt;&#123;0&#125;, Mat(), hist, vector&lt;int&gt;&#123;256&#125;, vector&lt;float&gt;&#123;0, 256&#125;); 注意：这里的vector后面使用的是大括号，注意vector大括号初始化和小括号初始化的差别。 Python 1hist = cv.calcHist([src], [0], None, [256], [0, 256]) 或者使用numpy的方式统计 12# 统计第1个通道,其他类似hist = np.bincount(src[:,0].ravel(), minlength=0) 绘制直方图C++中绘制直方图比较麻烦，我们使用polylines取画出多边形，从而形成直方图。抽成自定义函数如下 12345678910111213void drawHist(Mat &amp;hist, const Scalar &amp;color = Scalar(0, 0, 255)) &#123; int bin = 4, width = 256 * bin, height = 800; vector&lt;Point&gt; points; Mat dst(height, width, CV_8UC3); // 标准化 Mat out; normalize(hist, out, 0, height - 100, NORM_MINMAX); for (int i; i &lt; hist.size().height; i++) &#123; points.push_back(Point(i * bin, 790 - out.at&lt;float&gt;(i))); &#125; polylines(dst, vector&lt;vector&lt;Point&gt;&gt;&#123;points&#125;, false, color, 1, LINE_AA); imshow(&quot;hist&quot;, dst);&#125; 在Python中使用Matplotlib即可，方便快捷高效。 12plt.plot(hist)plt.show() HSV模型HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R. Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone Model)。 这个模型中颜色的参数分别是：色调（H），饱和度（S），明度（V） 当 S = 1，V=1时，H所代表的任何颜色被称为纯色 当 S = 0，即饱和度为0，颜色最浅，最浅被描述为灰色，灰色的亮度由V决定，此时H无意义 当 V = 0 时，颜色最暗，最暗被描述为黑色，因此此时H和S均无意义。 注意：在OpenCV中，H、S、V的取值范围是[0, 180]、[0, 255]、[0, 255]，而不是[0, 360]、[0, 1]、[0, 1] 下面列出部分的HSV空间颜色值： 图像二值化手动设置阈值1threshold(src, dst, thresh, maxval, type) src：单通道灰度图 thresh：阈值 maxval：最大值（一般取255） type：类型 当前公式解析有问题，公式来源 参数名 参数解释 THRESH_BINARY $dst\\left( x,y\\right) =\\begin{cases}maxval &amp; if\\ src(x, y)\\ &gt;\\ thresh \\ 0\\end{cases}$ THRESH_BINARY_INV $dst\\left( x,y\\right) =\\begin{cases}0 &amp; if\\ src(x, y)\\ &gt;\\ thresh \\ maxval\\end{cases}$ THRESH_TRUNC $dst\\left( x,y\\right) =\\begin{cases}threshold &amp; if\\ src(x, y)\\ &gt;\\ thresh \\ src(x,y)\\end{cases}$ THRESH_TOZERO $dst\\left( x,y\\right) =\\begin{cases}src(x,y) &amp; if\\ src(x, y)\\ &gt;\\ thresh \\ 0\\end{cases}$ THRESH_TOZERO_INV $dst\\left( x,y\\right) =\\begin{cases}0 &amp; if\\ src(x, y)\\ &gt;\\ thresh \\ src(x,y) \\end{cases}$ OpenCV官网使用了一张图片来描述这5个参数不同的含义，如下： 除了上面的5个参数，还有两个自动算法标志： 参数名 参数解释 THRESH_OTSU 大津算法 THRESH_TRIANGLE 三角算法（常用在图中出现大量的近视颜色的情况下） C++ 123456Mat dst;// 手动填写阈值threshold(src, dst, 100, 255, THRESH_BINARY);// 大津算法，手动输入的阈值无效，三角算法类似，正确的阈值需要通过返回值获取。threshold(src, dst, 100, 255, THRESH_BINARY | THRESH_OTSU); Python 12345# retval 实际阈值retval, dst = cv.threshold(src, 100, 255, cv.THRESH_BINARY)# 大津算法retval, dst = cv.threshold(src, 100, 255, cv.THRESH_BINARY | cv.THRESH_OTSU) 自适应阈值1adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, C) adaptiveMethod：自适应阈值算法 ADAPTIVE_THRESH_MEAN_C：附近区域减去恒定的平均C ADAPTIVE_THRESH_GAUSSIAN_C：领域值减去参数C的高斯加权和 thresholdType：阈值类型，只允许是以下两个 THRESH_BINARY：超过阈值是maxval，低于阈值是0 THRESH_BINARY_INV：超过阈值是0，低于阈值是maxval blockSize：邻域大小，必须是奇数。 C：参数C C++ 1adaptiveThreshold(src, dst, 255, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 3, 5); Python 1234dst = cv.adaptiveThreshold(src, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 3, 5) 图片卷积自定义卷积核1filter2D(src, dst, ddepth, kernel) ddepth：目标图像的深度 kernel：卷积核 官网给出的计算的公式：$$\\texttt{dst} (x,y) = \\sum _{ \\stackrel{0\\leq x’ &lt; \\texttt{kernel.cols},}{0\\leq y’ &lt; \\texttt{kernel.rows}} } \\texttt{kernel} (x’,y’)* \\texttt{src} (x+x’- \\texttt{anchor.x} ,y+y’- \\texttt{anchor.y} )$$C++ 12345678910111213141516171819202122Mat dst;// 1. 均值滤波Mat means_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; 1, 1, 1, 1, 1, 1, 1, 1, 1) / 9;// 2. 高斯模糊Mat gaussian_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; 1, 2, 1, 2, 4, 2, 1, 2, 1) / 16;// 3. Sobel 算子// 3.1 水平梯度Mat sobel_h_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; -1, 0, 1, -2, 0, 2, -1, 0, 1);// 3.2 垂直梯度Mat sobel_v_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; -1, -2, -1, 0, 0, 0, 1, 2, 1);// 4. 拉普拉斯算子// 4.1 普通型Mat laplacian_normal_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; 0, 1, 0, 1, -4, 1, 0, 1, 0);// 4.2 增强型Mat laplacian_strong_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; 1, 1, 1, 1, -4, 1, 1, 1, 1);// 5. 锐化滤波Mat sharpen_kernel = (Mat_&lt;float&gt;(3, 3) &lt;&lt; -1, -1, -1, -1, 9, -1, -1, -1, -1);// 以均值滤波为例，其他都是一样的使用方式filter2D(src, dst, -1, means_kernel); Python 123456789101112131415161718192021222324252627282930313233# 1. 均值滤波means_kernel = np.float32(((1, 1, 1), (1, 1, 1), (1, 1, 1))) / 9# 2. 高斯模糊gaussian_kernel = np.float32(((1, 2, 1), (2, 4, 2), (1, 2, 1))) / 16# 3. Sobel 算子# 3.1 水平梯度sobel_h_kernel = np.float32(((-1, 0, 1), (-2, 0, 2), (-1, 0, 1)))# 3.2 垂直梯度sobel_v_kernel = np.float32(((-1, -2, -1), (0, 0, 0), (1, 2, 1)))# 4. 拉普拉斯算子# 4.1 普通型laplacian_normal_kernel = np.float32(((0, 1, 0), (1, -4, 1), (0, 1, 0)))# 4.2 增强型laplacian_strong_kernel = np.float32(((1, 1, 1), (1, -4, 1), (1, 1, 1)))# 5. 锐化滤波sharpen_kernel = np.float32(((-1, -1, -1), (-1, 9, -1), (-1, -1, -1)))# 以均值滤波为例，其他都是一样的使用方式dst = cv.filter2D(src, -1, means_kernel) 自定义卷积核比较灵活，只要定好卷积核，就可以使用该方法进行卷积。 均值滤波1blur(src, dst, ksize) ksize：卷积核尺寸 C++：Size类型 Python：元组类型 C++ 高斯模糊1GaussianBlur(src, dst, ksize, sigmaX, sigmaY) sigmaX：x轴上的高斯标准差 sigmaY：y轴上的高斯标准差，如果为0，设置为等于sigmaY **C++**： 12Mat dst;GaussianBlur(src, dst, Size(3, 3), 1, 1); Python 1dst = cv.GaussianBlur(src, (3, 3), 1, 1) 中值滤波1medianBlur(src, dst, ksize) 注意此处的 ksize 为int类型 C++ 1medianBlur(src, dst, 3); Python Sobel算子1Sobel(src, dst, ddepth, dx, dy, ksize&#x3D;3) dx：沿x轴的阶数 dy：沿y轴的阶数 C++ Python 12345# 沿 x 轴计算一阶sobeldst = cv.Sobel(src, -1, 1, 0)# 沿 y 轴计算一阶sobeldst = cv.Sobel(src, -1, 0, 1) Scharr滤波器1Scharr(src, dst, ddepth, dx, dy) C++ 12345// 沿 x 轴计算一阶 ScharrScharr(src, dst, -1, 1, 0);// 沿 y 轴计算一阶 ScharrScharr(src, dst, -1, 0, 1); Python 12345# 沿 x 轴计算一阶 Scharrdst = cv.Scharr(src, -1, 1, 0)# 沿 y 轴计算一阶 Scharrdst = cv.Scharr(src, -1, 0, 1) 拉普拉斯算子1Laplacian(src, dst, ddepth, ksize&#x3D;1) C++ 1Laplacian(src, dst, -1); Python 1dst = cv.Laplacian(src, -1) canny边缘检测算法1Canny(src, edges, threshold1, threshold2) edges：边缘图，单通道8位。 threshold1：第一个阈值 threshold2：第二个阈值 C++ 1Canny(src, dst, 50, 100); Python 1dst = cv.Canny(src, 50, 100) 双边滤波1bilateralFilter(src, dst, d, sigmaColor, sigmaSpace) d：滤波期间使用的每个像素邻域的直径。 sigmaColor：在色彩空间中过滤的标准差 sigmaSpace：在坐标空间中过滤的标准差 C++ 1bilateralFilter(src, dst, 3, 1, 1); Python 1dst = cv.bilateralFilter(src, 3, 1, 1) 霍夫变换霍夫圆使用霍夫变换在灰度图中查找圆 12HoughCircles(src, circles, method, dp, minDist, param1&#x3D;100, param2&#x3D;100, minRadius&#x3D;0, maxRadius&#x3D;0) circles：找到的圆的输出向量 method：检测方法 当前唯一实现的方法是HOUGH_GRADIENT dp：分辨率，累加器分辨率和图像分辨率的反比。 minDist：检测到圆心的最小距离 param1：传递给Canny边缘检测器的两个阈值中的更高的那个，更低的是它的一半 param2：它是检测圆心的累加器阈值，越小，假圆可能越多。 minRadius：最小圆半径 maxRadius：最大圆半径 C++ 123Mat circles;HoughCircles(src, circles, HOUGH_GRADIENT, 1, 100, 160, 50, 0, 1000);// circles 中是检测到的圆的圆心(x, y)和半径 Python 1circles = cv.HoughCircles(src, HOUGH_GRADIENT, 1, 100, 160, 50, 0, 1000) 霍夫直线变换–找直线 使用标准霍夫变换或者标准多尺度霍夫变换查找直线 12HoughLines(src, lines, rho, theta, threshold, srn&#x3D;0, stn&#x3D;0, min_theta&#x3D;0, max_theta&#x3D;CV_PI) lines：检测出来的直线（里面的参数是rho和theta） rho：距离分辨率（以像素为单位） theta：角度分辨率（以弧度为单位） threshold：累加器阈值 srn：它是距离分辨率rho的除数 stn：它是角度分辨率theta的除数，如果两个都等于0，则使用标准霍夫变换。否则使用多尺度霍夫变换 min_theta：最小角度：介于0和max_theta之间 max_theta：最大角度：介于min_theta和CV_PI之间 注意：输入图必须是二值图 C++ 1234567// 将 src 转化为二值图Mat binary;adaptiveThreshold(src, binary, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 5, 1);Mat lines;HoughLines(binary, lines, 1, CV_PI / 180, 100); Python 12345# 将 src 转化为二值图binary = cv.adaptiveThreshold( src, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 5, 1)lines = cv.HoughLines(binary, 1, np.pi / 180, 100) 注意 lines 的参数分别对应的是一条直线的 rho 和 theta 霍夫直线变换–找线段 使用概率霍夫变换在二进制图像中查找线段 1HoughLinesP(src, lines, rho, theta, theshold, minLineLength&#x3D;0, maxLineGap&#x3D;0) minLineLength：线段的最小长度。 maxLineGap：连接该线上的点之间的最大允许间隙。 注意：输入图必须是二值图 C++ 123456789101112Mat binary, gray;cvtColor(src, gray, COLOR_BGR2GRAY);adaptiveThreshold(gray, binary, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY_INV, 5, 1);imshow(&quot;binary&quot;, binary);vector&lt;Vec4i&gt; lines;HoughLinesP(binary, lines, 1, CV_PI / 180, 200, 150, 30);for (auto line : lines) &#123; cv::line(src, Point(line[0], line[1]), Point(line[2], line[3]), Scalar(0, 0, 255), 2);&#125;imshow(&quot;src&quot;, src); Python 12345678910gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)binary = cv.adaptiveThreshold( gray, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, 5, 1)lines = cv.HoughLinesP(binary, 1, np.pi / 180, 200, 150, 30)for line in lines: x1, y1, x2, y2 = line[0] cv.line(src, (x1, y1), (x2, y2), (0, 0, 255), 2)cv.imshow(&quot;binary&quot;, binary)cv.imshow(&quot;src&quot;, src) 注意：实际使用中，C++的HoughLineP 和Python的HoughLineP最终的结果有差异，原因未知。 查找轮廓和绘制轮廓查找轮廓 1findContours(image, contours, hierachy, mode, method) 参数描述： image：二值图 contours：查找到的所有轮廓 hierachy：层级关系（目前很少用到） mode：轮廓的检索模式 RETR_EXTERNAL：仅检索外部轮廓。 RETR_LIST：不建立索引关系的情况下，检索所有轮廓。 RETR_CCOMP：检索所有轮廓，分为两级层次结构。 RETR_TREE：检索所有轮廓，重建嵌套的完整结构。 method：轮廓近似方法 CHAIN_APPROX_NONE：绝对存储所有轮廓点 CHAIN_APPROX_SIMPLE：压缩水平，垂直和对角线段，仅保留其端点。 绘制轮廓 1drawContours(image, contours, contourIdx, color, thickness, lineType) contours：上面方法找到的所有轮廓点 countourIdx：要绘制的索引，-1代表所有 C++ 1234567Mat gray, binary;cvtColor(src, gray, COLOR_BGR2GRAY);adaptiveThreshold(gray, binary, 255, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY_INV, 255, 1);vector&lt;vector&lt;Point&gt;&gt; contours;findContours(binary, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);drawContours(src, contours, -1, Scalar(0, 0, 255), 1); Python 12345678910gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)binary = cv.adaptiveThreshold( gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 255, 1)_, contours, hierarchy = cv.findContours( binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)cv.drawContours(src, contours, -1, (0, 0, 255), 1)cv.imshow(&quot;binary&quot;, binary)cv.imshow(&quot;src&quot;, src) 注意：findContours会返回三个值，分别是，图像，轮廓，层级。 膨胀和腐蚀形态学变化是基于图像形状的一些简单操作。操作对象一般是二值图像，需要两个输入，一个是我们的原图，另一个是3x3的结构元素(内核)，决定了膨胀操作的本质。常见的操作是图像的膨胀和腐蚀。以及他们的进阶操作注入Opening、Closing、Gradient等等。 获取结构元素1getStructuringElement(shape, ksize) shape： 结构元素的形状 MORPH_RECT：矩形结构元素 MORPH_CROSS：十字形结构元素 MORPH_ELLIPSE：椭圆形结构元素 用法在下面 膨胀用大值填充小值 1dilate(src, dst, kernel) kernel：结构元素 C++ 12345Mat dilate_later;Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5));dilate(src, dilate_later, kernel);imshow(&quot;src&quot;, src);imshow(&quot;binary&quot;, dilate_later); Python 1234kernel = cv.getStructuringElement(cv.MORPH_RECT, (5, 5))dilate_later = cv.dilate(src, kernel)cv.imshow(&quot;src&quot;, src)cv.imshow(&quot;binary&quot;, dilate_later) 腐蚀用小值填充大值 1erode(src, dst, kernel) C++ 12345Mat erode_later;Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5));erode(src, erode_later, kernel);imshow(&quot;src&quot;, src);imshow(&quot;binary&quot;, erode_later); Python 1234kernel = cv.getStructuringElement(cv.MORPH_RECT, (5, 5))erode_later = cv.erode(src, kernel)cv.imshow(&quot;src&quot;, src)cv.imshow(&quot;binary&quot;, erode_later) 高级形态转化1morphologyEx(src, dst, op, kernel) op：形态转化方式 MORPH_ERODE：腐蚀 MORPH_DILATE：膨胀 MORPH_OPEN：开操作，先腐蚀后膨胀 MORPH_CLOSE：闭操作，先膨胀后腐蚀 … C++ 123456Mat src_later;Mat kernel = getStructuringElement(MORPH_RECT, Size(5, 5));// 开操作，其他操作将 op 的值进行更换即可morphologyEx(src, src_later, MORPH_OPEN, kernel);imshow(&quot;src&quot;, src);imshow(&quot;binary&quot;, src_later); Python 12345kernel = getStructuringElement(cv.MORPH_RECT, Size(5, 5))# 开操作，其他操作将 op 的值进行更换即可src_later = cv.morphologyEx(src, cv.MORPH_OPEN, kernel)cv.imshow(&quot;src&quot;, src)cv.imshow(&quot;binary&quot;, src_later) 泛洪填充（漫水填充）1floodFill(image, mask，seedPoint, newVal, rect, loDiff&#x3D;Scalar(), upDiff&#x3D;Scalar(), flags) seedPoint：起始点 newVal：新值 rect：最小边界矩形，一般使用默认 loDiff：最大较低色差 upDiff：最大较高色差 flags：操作标志 FLOODFILL_FIXED_RANGE $$\\texttt{src} (x’,y’)- \\texttt{loDiff} \\leq \\texttt{src} (x,y) \\leq \\texttt{src} (x’,y’)+ \\texttt{upDiff}$$ C++ 123// &#123;5, 5&#125; 是一种简写方式，会自动生成 Point，&#123;0, 0, 255&#125;同理，会自动生成 ScalarfloodFill(src, &#123;5, 5&#125;, &#123;0, 0, 255&#125;);imshow(&quot;src&quot;, src); Python 12cv.floodFill(src, (5, 5), (0, 0, 255));cv.imshow(&quot;src&quot;, src); 图像分水岭1watershed(image, markers) markders：标记，类型必须是CV_32S C++ 12345678910Mat markers(src.size(), CV_32S);circle(markers, &#123;src.size().width / 2, src.size().height / 2&#125;, 2, &#123;255&#125;, -1);circle(markers, &#123;10, 10&#125;, 2, &#123;1&#125;, -1);watershed(src, markers);std::cout &lt;&lt; markers &lt;&lt; std::endl;Mat result;markers.convertTo(result, CV_8UC3);imshow(&quot;src&quot;, src);imshow(&quot;result&quot;, result); Python 12345678height, width = src.shape[:2]markers = np.zeros(src.shape[:2], np.int32)cv.circle(markers, (width // 2, height//2), 2, (255), -1)cv.circle(markers, (10, 10), 2, (1), -1)cv.watershed(src, markers)markers = markers.astype(np.uint8)cv.imshow(&quot;src&quot;, src)cv.imshow(&quot;binary&quot;, markers) 注意：标定点一般需要我们实际取获取。这里仅仅是使用固定点举例子罢了。 距离变换1distanceTransform(src, dst, distanceType, maskSize, dstType&#x3D;CV_32F) src：8位单通道二进制图 dst：输出具有计算出的距离图像。它是大小与src相同的8位或32位浮点单通道图像。 distanceType：距离类型，一般采用欧式距离就好了 DIST_L1：distance = |x1-x2| + |y1-y2| DIST_L2：简单的欧式距离 DIST_C：distance = max(|x1-x2|,|y1-y2|) DIST_L12：L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) DIST_FAIR：distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 DIST_WELSCH：distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 DIST_HUBER：distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 maskSize：距离变换蒙版大小，一般用3或5 dstType：输出类型，一般采用默认值 C++ 123456789Mat gray, binary, dst;cvtColor(src, gray, COLOR_BGR2GRAY);adaptiveThreshold(gray, binary, 255, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY_INV, 255, 1);distanceTransform(binary, dst, DIST_L2, 3);// 将数据归一化到0-1之间，显示效果比较好normalize(dst, dst, 0, 1, NORM_MINMAX);imshow(&quot;dst&quot;, dst);imshow(&quot;binary&quot;, binary); Python 12345678gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)binary = cv.adaptiveThreshold( gray, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 255, 1)dst = cv.distanceTransform(binary, cv.DIST_L2, 3)# 将数据归一化到0-1之间，显示效果比较好cv.normalize(dst, dst, 0, 1, cv.NORM_MINMAX)cv.imshow(&quot;binary&quot;, binary)cv.imshow(&quot;dst&quot;, dst)","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"}]},{"title":"OpenCV 入门","slug":"OpenCV 入门","date":"2019-10-23T12:00:00.000Z","updated":"2019-10-23T12:00:00.000Z","comments":true,"path":"2019/e181f182.html","link":"","permalink":"https://askeynil.github.io/2019/e181f182.html","excerpt":"图像的读写与显示读取图像使用函数 cv.imread() 来读取图像，该函数共两个参数 图像的路径 图像的读取方式 cv.IMREAD_COLOR 加载彩色图像，图像的任何透明度都将被忽略。这是默认标志 cv.IMREAD_GRAYSCALE 以灰度模式加载图像 cv.IMREAD_UNCHANGED 加载图像，包括 alpha 通道 例： 123import cv2 as cvimg = cv.imread(&quot;1.jpg&quot;, cv.IMREAD_COLOR) 警告：如果图像路径错误，它将不会引发任何错误，但是会返回一个空值","text":"图像的读写与显示读取图像使用函数 cv.imread() 来读取图像，该函数共两个参数 图像的路径 图像的读取方式 cv.IMREAD_COLOR 加载彩色图像，图像的任何透明度都将被忽略。这是默认标志 cv.IMREAD_GRAYSCALE 以灰度模式加载图像 cv.IMREAD_UNCHANGED 加载图像，包括 alpha 通道 例： 123import cv2 as cvimg = cv.imread(&quot;1.jpg&quot;, cv.IMREAD_COLOR) 警告：如果图像路径错误，它将不会引发任何错误，但是会返回一个空值 显示图像使用函数 cv.imshow() 在窗口显示图像，窗口自动适合图像尺寸。该函数共两个参数。 窗口名称 要显示的图像 可以根据需求创建任意多个窗口，但需要使用不同的窗口名称 例： 123cv.imshow(&#x27;image&#x27;, img)cv.waitkey()cv.destoryAllWindows() cv.waitkey()等待按键按下功能，其参数是时间（以毫秒为单位），默认为0，即永远等待。 cv.destoryAllWindows() 用来回收我们创建的所有窗口。 保存图像使用函数cv.imwrite()来保存图像，该函数共两个参数。 文件名 需要保存的图像 1cv.imwrite(&#x27;2.jpg&#x27;, img) 图像的基本操作 来源：https://docs.opencv.org/4.1.2/d3/df2/tutorial_py_basic_ops.html 本节中的大部分操作都与numpy相关，因为要操作图像数据，而图像数据就是一个np.ndarray的数组。 注意：在OpenCV中图像都处于GBR模式，使用这种方式的是因为历史遗留问题，在早年大部分的照相机制造商和软件供应商中流行的就是BGR模式， OpenCV为了迎合当时开发者的习惯就是用了BGR模式，然而在当今这个时代RGB又流行了起来，OpenCV已经无法在兼容RGB模式了，所以只能这样将就着使用GBR模式了 访问和修改像素值1234567891011121314import numpy as npimport cv2 as cvimg = cv.imread(&#x27;1.jpg&#x27;)px = img[100, 100]# [2 6 26]# 也可以仅接收 rgb的任意一个值blue = img[100, 100, 0]# 或blue, green, red = img[100, 100] # 不想接收的可以用 _ 代替# 修改像素值img[100, 100] = 255, 255, 255 警告：Numpy是用于快速数组计算的优化库。因此，简单的访问每个元素并对其进行修改是非常缓慢的，不建议这样使用。 更好的访问像素值和修改像素值的方法 12345# 访问 RED 的值img.item(100, 100, 2)# 修改 RED 的值img.itemset((100, 100, 2), 100) 访问图像属性图像的属性包括：行、列、通道数、图像的数据类型、像素数等等 图像的形状可以通过img.shape访问。它返回行，列和通道数的元组（如果是彩色的图像） 12print(img.shape)# (1227 690 3) 注意：如果图像是灰度的，则返回的元组只会包含行和列，因此这是检测加载的图像是灰度还是彩色的好方法。 像素总数可以通过img.size进行获取： 12print(img.size)# 846630 图像数据类型可以通过img.dtype进行获取 12print(img.dtype)# uint8 注意： img.dtype在调试的时候非常重要，因为OpenCV-Python代码中大部分的错误可能都是因为无效数据类型引起的。 图像ROI（Region Of Internest）有时候我们需要使用图像的某个区域，这是可以通过NumPy索引的方式获取ROI 12# 获取图像第220行到500行，250行到620行的图像img[220:500, 250:620] 注意：如果对裁剪区域内容进行修改，这个值也会反馈裁剪之前的图像数组，因为在NumPy中默认使用的是引用拷贝的方式，所以在需要对特定的区域修改的时候，我们可以将其裁剪出来，然后在更小的区域做处理，这样可以提高我们修改的速度和准确性。 分割和合并图像通道有的时候需要分别处理图像的G、B、R通道。可以使用以下方法做到这一点： 12345678# 拆分b, g, r = cv.split(img)# 或b = img[:, :, 0]g = img[:, :, 1]r = img[:, :, 2]# 合并img = cv.merge((b, g, r)) 警告：cv.split()是一项非常耗时的操作，相比于numpy的索引而言，实测速度大约相差百倍，数据量大的情况下可以到几百倍。 为图像设置边框（填充）如果要在图像周围创建边框，则可以使用 cv.copyMakeBorder()。但是它在卷积运算，零填充等方便有更多的运用。该函数共7个参数： src 输入的图像 top 上边界宽度 bottom 下边界宽度 left 左边界宽度 right 右边界宽度 borderType 边界类型 cv.BORDER_CONSTANT 添加恒定的色彩边框 cv.BORDER_REFLECT 边框是边框元素的镜像，例如：fedcba | abcdefgh |hgfedcb cv.BORDER_REFLECT_101 或 cv.BORDER_DEFAULT ，与上述基本相同，但是略有变化。例如：gfedcb | abcdefgh | gfedcba cv.BORDER_REPLICATE 最后一个元素被复制，例如：aaaaaa | abcdefg | gggggg cv.BORDER_WRAP 例如：cdefgh | abcdefgh | abcdefg value 颜色值，类型为cv.BORDER_CONSTANT有效 图像上的算术运算 来源：https://docs.opencv.org/4.1.2/d0/d86/tutorial_py_image_arithmetics.html 图像加法图像的加法可以通过OpenCV函数cv.add()或仅通过NumPy操作（res = img1 + img2）。两个图像应该具有相同的深度和类型，或者第二个图像可以只有一个标量。 注意：OpenCV的加法是饱和运算，而NumPy的加法是模运算，简单的讲就是，当相加的结果超过255的时候，OpenCV的相加的值为255，而NumPy相加的值为其取模的值 图像融合这也类似于图像的加法，但是对图像赋予的权重不同，以使其具有融合或者透明的感觉。根据以下等式添加图像：$$g(x)=(1-\\alpha)f_{0}(x)+(\\alpha)f_{1}(x)$$在 OpenCV 中，我们可以使用cv.addWeighted()函数来达到图像融合的效果，该函数有7个参数： src1：第一个输入的数组 alpha：第一个数组元素的权重 src2：第二个输入的数组 beta：第二个数组元素的权重 gamma：标量，加到每个元素中。 dst：输出数组 dtype：输出的数据类型 大致可以表示为如下方程式：$$dst = \\alpha \\cdot img_{1} + \\beta \\cdot img_{2} + \\gamma$$","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"}],"tags":[{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"}]},{"title":"Service 通讯","slug":"Service 通讯","date":"2019-10-21T07:00:00.000Z","updated":"2019-10-21T07:00:00.000Z","comments":true,"path":"2019/a2babe33.html","link":"","permalink":"https://askeynil.github.io/2019/a2babe33.html","excerpt":"Service通讯机制Service通讯分为client端和server端。 client端负责发送请求(Request)给server端。 server端负责接收client端发送的请求数据。 server端收到数据后，根据请求数据和当前的业务需求，产生数据，将数据(Response)返回给client端。 Service通讯的特点： 同步数据访问 具有响应反馈机制 一个server多个client 注重业务逻辑处理","text":"Service通讯机制Service通讯分为client端和server端。 client端负责发送请求(Request)给server端。 server端负责接收client端发送的请求数据。 server端收到数据后，根据请求数据和当前的业务需求，产生数据，将数据(Response)返回给client端。 Service通讯的特点： 同步数据访问 具有响应反馈机制 一个server多个client 注重业务逻辑处理 Service通讯的关键点： service的地址名称 client端访问server端的数据格式 server端响应client端的数据格式 Service通讯架构如下图： 文本使用服务端接收数据端数据，并进行简单的加法运算后返回给客户端 首先在ws的src的目录下，使用catkin_create_pkg demo_service roscpp rospy rosmsg 创建 demo_service package ServerC++ 版本 在src目录下创建一个server.cc文件，将以下代码粘贴到到该文件中 12345678910111213141516// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;cpp_server&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // todo 处理业务逻辑 // 进入一个简单的事件循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_server src/server.cc)# 添加该可执行程序的依赖库target_link_libraries( demo_server $&#123;catkin_LIBRARIES&#125;) 创建 Server 对象 导入要发送的消息的头文件 1#include &quot;roscpp_tutorials/TwoInts.h&quot; 创建对象，并发送消息 12345// 创建 service 名称char service_name[] = &quot;demo_service&quot;;// 创建一个 serverconst ros::ServiceServer &amp;server = node.advertiseService(service_name, serviceCallback); 创建 serviceCallback 回调函数 1234567bool serviceCallback(roscpp_tutorials::TwoInts::Request &amp;request, roscpp_tutorials::TwoInts::Response &amp;response) &#123; // 返回值 bool：true代表成功响应，false代表拒绝响应 // 可根据业务实际情况返回相应数据，本例就不做false处理了 response.sum = request.a + request.b; return true;&#125; 编译该节点，在工作空间目录下 1catkin_make Python 版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 server.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;py_server&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 处理业务逻辑 # 开启 ros 运行时循环 rospy.spin() 创建 Server 对象 导入要发送的消息的头文件 1from rospy_tutorials.srv import AddTwoInts, AddTwoIntsRequest, AddTwoIntsResponse 创建对象，并发送消息 1234# 创建 Service 名称service_name = &quot;demo_service&quot;# 创建 serverserver = rospy.Service(service_name, AddTwoInts, serviceCallback) 创建 serviceCallback 回调函数 1234567def serviceCallback(request=AddTwoIntsRequest()): response = AddTwoIntsResponse() response.sum = request.a + request.b # 返回一个对应类型的 response 代表成功响应 # 返回空值，代表拒绝响应 # 在 Python 中可以更加灵活的使用返回数据，此例返回 a+b 也可以达到效果 return response 给 server.py 赋予可执行权限 1chmod a+x src/demo_service/scripts/server.py 使用rosservice调试 将当前工作空间的环境变量添加到bash或zsh中 123# 根据使用不同的 shell 使用不同的环境变量，两者选其一source devel/setup.bash # 使用 bashsource devel/setup.zsh # 使用 zsh 运行 server 程序 c++ 程序 1rosrun demo_service demo_server python 程序 1rosrun demo_service server.py 使用rosservice call /demo_service &quot;a: 2 b: 1&quot; 响应数据 sum: 3 使用 rqt_service_caller 调试前两步与上面相同，然后使用rosrun rqt_service_caller rqt_service_caller 选择对应的service，本例为demo_service 填充数据后按右上角的call发送 示意图如下所示 总结 使用第三方的srv与msg类似，这里就不做赘述，配置方法与msg一样，详情可见 在回调函数的使用中，Python 与 C++ 的参数不一样，C++通过返回bool值判断是否成功响应，Python通过是否返回空值判断是否成功响应。 C++使用node.advertiseService创建server Python使用rospy.Service创建server ClientC++ 版本 在src目录下创建一个client.cc文件，将以下代码粘贴到到该文件中 1234567891011121314151617// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;cpp_client&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // todo 处理业务逻辑 // 进入一个简单的事件循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_client src/client.cc)# 添加该可执行程序的依赖库target_link_libraries( demo_client $&#123;catkin_LIBRARIES&#125;) 创建 Client 对象 导入要发送的消息的头文件 1#include &quot;roscpp_tutorials/TwoInts.h&quot; 创建对象，并发送消息 123456789101112131415 // 创建 service 名称 char service_name[] = &quot;demo_service&quot;; // 创建 Client ros::ServiceClient client = node.serviceClient&lt;roscpp_tutorials::TwoInts&gt;(service_name); // 创建一个Request 和 Responseroscpp_tutorials::TwoInts::Request request; roscpp_tutorials::TwoInts::Response response;request.a = 1, request.b = 2; if (client.call(request, response)) &#123; // 判断是否响应 // 获取到响应的数据 std::cout &lt;&lt; response.sum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;服务器 拒绝&quot; &lt;&lt; std::endl; &#125; 编译该节点，在工作空间目录下 1catkin_make Python 版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 client.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;py_client&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 处理业务逻辑 # 开启 ros 运行时循环 rospy.spin() 创建 Client 对象 导入要发送的消息的头文件 1from rospy_tutorials.srv import AddTwoInts, AddTwoIntsRequest, AddTwoIntsResponse 创建对象，并发送消息 123456789101112# 创建 Service 名称service_name = &quot;demo_service&quot;# 创建 serverclient = rospy.ServiceProxy(service_name, AddTwoInts)# 创建 Requestrequest = AddTwoIntsRequest()request.a, request.b = 1, 2try: response = client.call(request) print(response.sum)except rospy.ServiceException as error: # 服务器拒绝响应的错误 print(&quot;服务器拒绝响应&quot;) 给 client.py 赋予可执行权限 1chmod a+x src/demo_service/scripts/client.py 调试运行之前写好的 Server 端，分别 C++ 程序和 Python 程序，即可。 C++ 程序 1rosrun demo_service demo_client python 程序 1rosrun demo_service client.py 总结 C++ 创建 Client 的方法为node.serviceClient&lt;srv_type&gt;(srv_name) Python 创建的 Client 的方法为rospy.ServiceProxy(srv_name, srv_type) C++ 以call的返回值的Yes，No来判断服务器是否响应 Python 使用 try...except判断是是否是rospy.ServiceException类型来判断服务器是否成功响应 代码块C++12345678910111213141516171819202122&quot;ros_create_server&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_server&quot;, &quot;body&quot;: [ &quot;// todo 填写 service 的类型&quot;, &quot;#include \\&quot;$&#123;1:service_class&#125;\\&quot;&quot;, &quot;&quot;, &quot;// todo 填写 service 的类型&quot;, &quot;bool serviceCallback($&#123;2:service_class&#125;::Request &amp;request,&quot;, &quot; $&#123;2:service_class&#125;::Response &amp;response) &#123;&quot;, &quot; // TODO 服务端需要处理的业务逻辑&quot;, &quot; // 返回值 bool：true代表成功响应，false代表拒绝响应&quot;, &quot; return true;&quot;, &quot;&#125;&quot;, &quot;&quot;, &quot;// 创建 service 名称&quot;, &quot;// todo 填写 service_name&quot;, &quot;char service_name[] = \\&quot;$&#123;3:service_name&#125;\\&quot;;&quot;, &quot;// 创建一个 server&quot;, &quot;const ros::ServiceServer &amp;server =&quot;, &quot; node.advertiseService(service_name, serviceCallback);&quot;, ] &#125; 12345678910111213141516171819202122&quot;ros_create_client&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_client&quot;, &quot;body&quot;: [ &quot;// todo 填写 service 的类型&quot;, &quot;#include \\&quot;$&#123;1:service_class&#125;\\&quot;&quot;, &quot;&quot;, &quot;// todo 填写 service_name&quot;, &quot;char service_name[] = \\&quot;$&#123;2:service_name&#125;\\&quot;;&quot;, &quot;// 创建 Client&quot;, &quot;ros::ServiceClient client =&quot;, &quot; node.serviceClient&lt;$&#123;3:service_class&#125;&gt;(service_name);&quot;, &quot;// 创建一个Request 和 Response&quot;, &quot;$&#123;3:service_class&#125;::Request request;&quot;, &quot;$&#123;3:service_class&#125;::Response response;&quot;, &quot;if (client.call(request, response)) &#123; // 判断是否响应&quot;, &quot; // 获取到响应的数据&quot;, &quot; // todo 进行获取到数据之后的业务逻辑处理&quot;, &quot;&#125; else &#123;&quot;, &quot; std::cout &lt;&lt; \\&quot;服务器 拒绝\\&quot; &lt;&lt; std::endl;&quot;, &quot;&#125;&quot;, ] &#125; Python1234567891011121314151617181920&quot;ros_create_server&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_server&quot;, &quot;body&quot;: [ &quot;# todo 填写 service 的类型&quot;, &quot;from $&#123;1&#125;.srv import $&#123;2&#125;, $&#123;2&#125;Request, $&#123;2&#125;Response&quot;, &quot;&quot;, &quot;&quot;, &quot;def serviceCallback(request=$&#123;2&#125;Request()):&quot;, &quot; response = $&#123;2&#125;Response()&quot;, &quot; # 返回一个对应类型的 response 代表成功响应&quot;, &quot; # 返回空值，代表拒绝响应&quot;, &quot; return response&quot;, &quot;&quot;, &quot;# 创建 Service 名称&quot;, &quot;# todo 填写一个 service 的名称&quot;, &quot;service_name = \\&quot;$&#123;3:service_name&#125;\\&quot;&quot;, &quot;# 创建 server&quot;, &quot;server = rospy.Service(service_name, $&#123;2&#125;, serviceCallback)&quot;, ] &#125;, 1234567891011121314151617181920&quot;ros_create_client&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_client&quot;, &quot;body&quot;: [ &quot;# todo 填写 service 的类型&quot;, &quot;from $&#123;1&#125;.srv import $&#123;2&#125;, $&#123;2&#125;Request, $&#123;2&#125;Response&quot;, &quot;&quot;, &quot;# 创建 Service 名称&quot;, &quot;service_name = \\&quot;$&#123;3&#125;\\&quot;&quot;, &quot;# 创建 Server&quot;, &quot;client = rospy.ServiceProxy(service_name, $&#123;2&#125;)&quot;, &quot;# 创建 Request&quot;, &quot;request = $&#123;2&#125;Request()&quot;, &quot;request.a, request.b = 1, 2&quot;, &quot;try:&quot;, &quot; response = client.call(request)&quot;, &quot; print(response.sum)&quot;, &quot;except rospy.ServiceException as error: # 服务器拒绝响应的错误&quot;, &quot; print(\\&quot;服务器拒绝响应\\&quot;)&quot;, ] &#125; 附录ServerC++1234567891011121314151617181920212223242526272829// 导入 ros 头文件#include &quot;roscpp_tutorials/TwoInts.h&quot;#include &lt;ros/ros.h&gt;bool serviceCallback(roscpp_tutorials::TwoInts::Request &amp;request, roscpp_tutorials::TwoInts::Response &amp;response) &#123; // 返回值 bool：true代表成功响应，false代表拒绝响应 // 可根据业务实际情况返回相应数据，本例就不做false处理了 response.sum = request.a + request.b; return true;&#125;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;cpp_server&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建 service 名称 char service_name[] = &quot;demo_service&quot;; // 创建一个 server const ros::ServiceServer &amp;server = node.advertiseService(service_name, serviceCallback); // 进入一个简单的事件循环 ros::spin(); return 0;&#125; Python12345678910111213141516171819202122232425262728#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom rospy_tutorials.srv import AddTwoInts, AddTwoIntsRequest, AddTwoIntsResponsedef serviceCallback(request=AddTwoIntsRequest()): response = AddTwoIntsResponse() response.sum = request.a + request.b # 返回一个对应类型的 response 代表成功响应 # 返回空值，代表拒绝响应 # 在 Python 中可以更加灵活的使用返回数据，此例返回 a+b 也可以达到效果 return responseif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;py_server&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建 Service 名称 service_name = &quot;demo_service&quot; # 创建 server server = rospy.Service(service_name, AddTwoInts, serviceCallback) # 开启 ros 运行时循环 rospy.spin() ClientC++123456789101112131415161718192021222324252627282930// 导入 ros 头文件#include &quot;roscpp_tutorials/TwoInts.h&quot;#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;cpp_client&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建 service 名称 char service_name[] = &quot;demo_service&quot;; // 创建 Client ros::ServiceClient client = node.serviceClient&lt;roscpp_tutorials::TwoInts&gt;(service_name); // 创建一个Request 和 Response roscpp_tutorials::TwoInts::Request request; roscpp_tutorials::TwoInts::Response response; request.a = 1, request.b = 2; if (client.call(request, response)) &#123; // 判断是否响应 // 获取到响应的数据 std::cout &lt;&lt; response.sum &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;服务器 拒绝&quot; &lt;&lt; std::endl; &#125; // 进入一个简单的事件循环 ros::spin(); return 0;&#125; Python123456789101112131415161718192021222324252627#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom rospy_tutorials.srv import AddTwoInts, AddTwoIntsRequest, AddTwoIntsResponseif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;py_client&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建 Service 名称 service_name = &quot;demo_service&quot; # 创建 server client = rospy.ServiceProxy(service_name, AddTwoInts) # 创建 Request request = AddTwoIntsRequest() request.a, request.b = 1, 2 try: response = client.call(request) print(response.sum) except rospy.ServiceException as error: # 服务器拒绝响应的错误 print(&quot;服务器拒绝响应&quot;) # 开启 ros 运行时循环 rospy.spin()","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS Service","slug":"ROS-Service","permalink":"https://askeynil.github.io/tags/ROS-Service/"}]},{"title":"消息的发布者（Publisher）","slug":"消息的发布者（Publisher）","date":"2019-10-18T04:00:00.000Z","updated":"2020-11-04T10:55:07.309Z","comments":true,"path":"2019/c8e84d4d.html","link":"","permalink":"https://askeynil.github.io/2019/c8e84d4d.html","excerpt":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 前文已经讲过 ROS 工作空间和包 ROS 消息（msg）和服务（srv） ROS 概述 以上是这篇文章的基础 以下所有文件都创建在 ws 的工作空间下","text":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 前文已经讲过 ROS 工作空间和包 ROS 消息（msg）和服务（srv） ROS 概述 以上是这篇文章的基础 以下所有文件都创建在 ws 的工作空间下 topic通讯机制ROS 中节点间通信，其中一方为消息的发布者，定义为Publisher，另一方为消息的订阅者，定义为Subscriber。考虑到消息需要广泛传播，ROS在设计中没有将该中设计为点对点的单一传递，而是有发布者发布数据到Topic中，想要获得消息的任何一方都可以在 topic 中去获取数据，类似于udp的广播机制，大致的通讯原理如下图： 使用命令catkin_create_pkg demo_topic roscpp rospy rosmsg 创建一个名为demo_topic的包 创建只发布std消息的节点c++版本 在src目录下创建一个 publisher.cc 文件，将以下代码添加到该文件中 12345678910111213141516// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_publisher&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // TODO 将业务逻辑写在此处 // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_publisher src/publisher.cc)# 添加该可执行程序的依赖库target_link_libraries( demo_publisher $&#123;catkin_LIBRARIES&#125;) 创建 Publisher 对象 导入要发送的消息的头文件 12// 先使用 std 库中的简易消息#include &quot;std_msgs/String.h 创建对象，并发送消息 12345678910111213// 创建一个 topic 的名称char topic_name[] = &quot;demo_topic&quot;;// 获取一个 publisher 的对象const ros::Publisher &amp;pub =node.advertise&lt;std_msgs::String&gt;(topic_name, 1000);// 创建一个要发送的消息对象std_msgs::String str;// 填充要发送的数据str.data = &quot;I send a message&quot;;// 使用 publisher 发送该消息while (ros::ok()) &#123; pub.publish(str);&#125; 编译该节点，在工作空间目录下 1catkin_make Python版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 publisher.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_publisher&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 将业务逻辑写在此处 # 开启 ros 运行时循环 rospy.spin() 创建 Publisher 对象 导入要发送的消息的头文件 12# 先使用 std 库中的简易消息from std_msgs.msg import String 创建对象，并发送消息 1234567891011# 创建一个 topic 名称topic_name = &quot;demo_topic&quot;# 创建一个发布者pub = rospy.Publisher(topic_name, String, queue_size=1000)# 创建一个要发布的消息string = String()# 填充要发布的消息string.data = &quot;I send a message&quot;# 使用 publisher 发送该消息while not rospy.is_shutdown(): pub.publish(string) 给 publisher.py 赋予可执行权限 1chmod a+x src/demo_topic/scripts/publisher.py 使用 rqt_topic 工具调试 将当前工作空间的环境变量添加到bash或zsh中 123# 根据使用不同的 shell 使用不同的环境变量，两者选其一source devel/setup.bash # 使用 bashsource devel/setup.zsh # 使用 zsh 运行 demo_publisher c++ 程序 1rosrun demo_topic demo_publisher python 程序 1rosrun demo_topic publisher.py 打开 rqt_topic 工具 1rosrun rqt_topic rqt_topic 勾选 demo_topic，结果如下 创建发布自定义消息的节点我们使用在ros消息讲过的demo_msgs包中的Team.msg来传输数据 c++版本 在src目录下创建一个 publisher1.cc 文件，将以下代码添加到该文件中 12345678910111213141516// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_publisher&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // TODO 将业务逻辑写在此处 // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_publisher1 src/publisher1.cc)# 添加该可执行程序的依赖库target_link_libraries( demo_publisher1 $&#123;catkin_LIBRARIES&#125;) 在CMakeLists.txt文件的find_package中添加demo_msgs的依赖 123456find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy demo_msgs) 创建 Publisher 对象 导入要发送的消息的头文件 1#include &quot;demo_msgs/Team.h&quot; 创建对象，并发送消息 1234567891011121314151617// 创建一个 topic 的名称char topic_name[] = &quot;demo_topic&quot;;// 获取一个 publisher 的对象const ros::Publisher &amp;pub = node.advertise&lt;demo_msgs::Team&gt;(topic_name, 1000);// 创建一个要发送的消息对象demo_msgs::Team team;// 填充要发送的数据team.name = &quot;I&#x27;m a team&quot;;team.leader.name = &quot;AskeyNil&quot;;team.leader.age = 18;team.location.angular.x = 1;team.location.linear.z = 2;// 使用 publisher 发送该消息while (ros::ok()) &#123; pub.publish(team);&#125; 编译该节点，在工作空间目录下 1catkin_make python版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 publisher1.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_publisher&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 将业务逻辑写在此处 # 开启 ros 运行时循环 rospy.spin() 创建 Publisher 对象 导入要发送的消息的头文件 1from demo_msgs.msg import Team 创建对象，并发送消息 123456789101112131415# 创建一个 topic 名称topic_name = &quot;demo_topic&quot;# 创建一个发布者pub = rospy.Publisher(topic_name, Team, queue_size=1000)# 创建一个要发布的消息team = Team()# 填充要发布的消息team.name = &quot;I&#x27;m a team&quot;team.leader.name = &quot;AskeyNil&quot;team.leader.age = 18team.location.angular.x = 1team.location.linear.z = 2# 使用 publisher 发送该消息while not rospy.is_shutdown(): pub.publish(team) 给 publisher.py 赋予可执行权限 1chmod a+x src/demo_topic/scripts/publisher.py 使用 rqt_topic 工具调试 将当前工作空间的环境变量添加到bash或zsh中 123# 根据使用不同的 shell 使用不同的环境变量，两者选其一source devel/setup.bash # 使用 bashsource devel/setup.zsh # 使用 zsh 运行 demo_publisher c++ 程序 1rosrun demo_topic demo_publisher1 python 程序 1rosrun demo_topic publisher1.py 打开 rqt_topic 工具 1rosrun rqt_topic rqt_topic 勾选 demo_topic，结果如下 总结 如果调用别的package中的消息，需要将对应package添加到CMakeLists.txt中即可使用 Python 文件在调用之前一定要给对应的程序可执行的权限 创建简单ros程序的时候有大致的固定格式，可以使用代码块将其包装起来，下文记录我在vscode中记录的代码块 注意：node_name是一个base name，其中不能包含 / 。 注意：如果发送频率太高，缓冲区中的消息大于我们设定的值，本文设置的是1000，则会默认丢弃掉最先发布的消息。 代码块C++ros_main1234567891011121314151617181920212223&quot;ros_main&quot;: &#123; &quot;prefix&quot;: &quot;ros_main&quot;, &quot;body&quot;: [ &quot;// 导入 ros 头文件&quot;, &quot;#include &lt;ros/ros.h&gt;&quot;, &quot;&quot;, &quot;int main(int argc, char **argv) &#123;&quot;, &quot; // 创建 ros 的节点名称&quot;, &quot; // todo 填写节点名称&quot;, &quot; char node_name[] = \\&quot;$&#123;1:node_name&#125;\\&quot;;&quot;, &quot; // 初始化 ros 节点&quot;, &quot; ros::init(argc, argv, node_name);&quot;, &quot; // 创建一个节点对象&quot;, &quot; ros::NodeHandle node;&quot;, &quot;&quot;, &quot; // todo 处理业务逻辑&quot;, &quot;&quot;, &quot; // 进入一个简单的事件循环&quot;, &quot; ros::spin();&quot;, &quot; return 0;&quot;, &quot;&#125;&quot;, ] &#125; ros_create_publisher123456789101112&quot;ros_create_publisher&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_publisher&quot;, &quot;body&quot;: [ &quot;// 创建一个 topic 的名称&quot;, &quot;// todo 填写 topic 名称&quot;, &quot;char topic_name[] = \\&quot;$&#123;1:topic_name&#125;\\&quot;;&quot;, &quot;// 获取一个 publisher 的对象&quot;, &quot;// todo 添加 topic 类型&quot;, &quot;const ros::Publisher &amp;pub =&quot;, &quot; node.advertise&lt;$&#123;2:topic_class&#125;&gt;(topic_name, 1000);&quot;, ] &#125; Pythonros_main123456789101112131415161718192021&quot;ros_main&quot;: &#123; &quot;prefix&quot;: &quot;ros_main&quot;, &quot;body&quot;: [ &quot;#!/usr/bin/env python&quot;, &quot;# coding: utf-8&quot;, &quot;&quot;, &quot;# 导入 rospy 依赖&quot;, &quot;import rospy&quot;, &quot;&quot;, &quot;if __name__ == \\&quot;__main__\\&quot;:&quot;, &quot; # 节点名称&quot;, &quot; # todo 填写节点名称&quot;, &quot; node_name = \\&quot;$&#123;1:node_name&#125;\\&quot;&quot;, &quot; # 初始化 ros 节点&quot;, &quot; rospy.init_node(node_name)&quot;, &quot; # todo 处理业务逻辑&quot;, &quot; # 开启 ros 运行时循环&quot;, &quot; rospy.spin()&quot;, &quot;&quot; ] &#125; ros_create_publisher1234567891011&quot;ros_create_publisher&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_publisher&quot;, &quot;body&quot;: [ &quot;# 创建一个 topic 名称&quot;, &quot;# todo 填写 topic 的名称&quot;, &quot;topic_name = \\&quot;$&#123;1:topic_name&#125;\\&quot;&quot;, &quot;# 创建一个发布者&quot;, &quot;# todo 填写 topic 的类型&quot;, &quot;pub = rospy.Publisher(topic_name, $&#123;2:topic_class&#125;, queue_size=1000)&quot;, ] &#125; 附录创建只发布std消息的节点的完整代码C++1234567891011121314151617181920212223242526272829#include &quot;std_msgs/String.h&quot;// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_publisher&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建一个 topic 的名称 char topic_name[] = &quot;demo_topic&quot;; // 获取一个 publisher 的对象 const ros::Publisher &amp;pub = node.advertise&lt;std_msgs::String&gt;(topic_name, 1000); // 创建一个要发送的消息对象 std_msgs::String str; str.data = &quot;I send a message&quot;; // 使用 publisher 发送该消息 while (ros::ok()) &#123; pub.publish(str); &#125; // 进入一个简单的事件循环 ros::spin(); return 0;&#125; Python12345678910111213141516171819202122232425#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom std_msgs.msg import Stringif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_publisher&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建一个 topic 名称 topic_name = &quot;demo_topic&quot; # 创建一个发布者 pub = rospy.Publisher(topic_name, String, queue_size=1000) # 创建一个要发布的消息 string = String() # 填充要发布的消息 string.data = &quot;I send a message&quot; # 使用 publisher 发送该消息 while not rospy.is_shutdown(): pub.publish(string) # 开启 ros 运行时循环 rospy.spin() 创建发布自定义消息的节点C++1234567891011121314151617181920212223242526272829303132#include &quot;demo_msgs/Team.h&quot;// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_publisher&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建一个 topic 的名称 char topic_name[] = &quot;demo_topic&quot;; // 获取一个 publisher 的对象 const ros::Publisher &amp;pub = node.advertise&lt;demo_msgs::Team&gt;(topic_name, 1000); // 创建一个要发送的消息对象 demo_msgs::Team team; // 填充要发送的数据 team.name = &quot;I&#x27;m a team&quot;; team.leader.name = &quot;AskeyNil&quot;; team.leader.age = 18; team.location.angular.x = 1; team.location.linear.z = 2; // 使用 publisher 发送该消息 while (ros::ok()) &#123; pub.publish(team); &#125; // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; Python1234567891011121314151617181920212223242526272829#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom demo_msgs.msg import Teamif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_publisher&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建一个 topic 名称 topic_name = &quot;demo_topic&quot; # 创建一个发布者 pub = rospy.Publisher(topic_name, Team, queue_size=1000) # 创建一个要发布的消息 team = Team() # 填充要发布的消息 team.name = &quot;I&#x27;m a team&quot; team.leader.name = &quot;AskeyNil&quot; team.leader.age = 18 team.location.angular.x = 1 team.location.linear.z = 2 # 使用 publisher 发送该消息 while not rospy.is_shutdown(): pub.publish(team) # 开启 ros 运行时循环 rospy.spin()","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS Topic","slug":"ROS-Topic","permalink":"https://askeynil.github.io/tags/ROS-Topic/"}]},{"title":"消息订阅者（Subscriber）","slug":"消息订阅者（Subscriber）","date":"2019-10-18T04:00:00.000Z","updated":"2020-11-04T10:55:07.310Z","comments":true,"path":"2019/b013f674.html","link":"","permalink":"https://askeynil.github.io/2019/b013f674.html","excerpt":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 前文已经讲过 ROS 工作空间和包 ROS 消息（msg）和服务（srv） ROS 概述 消息的发布者（Publisher） 以上是这篇文章的基础 以下所有文件都创建在 ws 的工作空间下","text":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 前文已经讲过 ROS 工作空间和包 ROS 消息（msg）和服务（srv） ROS 概述 消息的发布者（Publisher） 以上是这篇文章的基础 以下所有文件都创建在 ws 的工作空间下 创建只订阅std消息的节点c++版本 在src目录下创建一个 subscriber.cc 文件，将以下代码添加到该文件中 12345678910111213141516// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_subscriber&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // TODO 将业务逻辑写在此处 // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_subscriber src/subscriber.cc)# 添加该可执行程序的依赖库target_link_libraries( subscriber $&#123;catkin_LIBRARIES&#125;) 创建 Subscriber 对象 导入要订阅的消息的头文件 12// 先使用 std 库中的简易消息#include &quot;std_msgs/String.h 创建对象，并订阅消息 1234// 创建一个 topic 的名称char topic_name[] = &quot;demo_topic&quot;;// 创建一个 Subscriber 对象 const ros::Subscriber &amp;sub = node.subscribe(topic_name, 1000, subCallback); 创建回调函数 1234void subCallback(const std_msgs::String::ConstPtr &amp;msg) &#123; // 一般写业务逻辑，此处打印接收到的数据 ROS_INFO_STREAM(msg-&gt;data);&#125; 编译该节点，在工作空间目录下 1catkin_make python版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 subscriber.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_subscriber&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 将业务逻辑写在此处 # 开启 ros 运行时循环 rospy.spin() 创建 Subscriber 对象 导入要订阅的消息的头文件 12# 先使用 std 库中的简易消息from std_msgs.msg import String 创建对象，并订阅消息 1234# 创建一个 topic 名称topic_name = &quot;demo_topic&quot;# 创建一个 Subscriber 对象sub = rospy.Subscriber(topic_name, String, subCallback) 创建回调函数 1234# 注意这个赋默认值是为了使后面有代码提示，实际过程中，msg 被传入的，所以不影响结果def subCallback(msg=String()): # 一般写业务逻辑，此处打印接收到的数据 print (msg.data) 给 subscriber.py 赋予可执行权限 1chmod a+x src/demo_topic/scripts/subscriber.py 使用 rqt_publisher 工具调试 将当前工作空间的环境变量添加到bash或zsh中 123# 根据使用不同的 shell 使用不同的环境变量，两者选其一source devel/setup.bash # 使用 bashsource devel/setup.zsh # 使用 zsh 运行 demo_publisher c++ 程序 1rosrun demo_topic demo_subscriber python 程序 1rosrun demo_topic subscriber.py 打开 rqt_publisher 工具 1rosrun rqt_publisher rqt_publisher 选择我们对应的Topic：demo_topic，Type选择std_msgs/String 勾选就会一直发送数据，或者右键点击Publisher Selected Once 可以发送一次数据 创建订阅自定义消息的节点我们使用在ros消息讲过的demo_msgs包中的Team.msg来传输数据 c++版本 在src目录下创建一个 subscriber1.cc 文件，将以下代码添加到该文件中 12345678910111213141516// 导入 ros 头文件#include &lt;ros/ros.h&gt;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_subscriber&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // TODO 将业务逻辑写在此处 // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; 在 CMakeLists.txt 中添加 add_executable 和 target_link_libraries 12345678910# 添加一个可执行程序add_executable( demo_subscriber1 src/subscriber1.cc)# 添加该可执行程序的依赖库target_link_libraries( demo_subscriber1 $&#123;catkin_LIBRARIES&#125;) 在CMakeLists.txt文件的find_package中添加demo_msgs的依赖 123456find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy demo_msgs) 创建 Publisher 对象 导入要发送的消息的头文件 1#include &quot;demo_msgs/Team.h&quot; 创建对象，并发送消息 1234// 创建一个 topic 的名称char topic_name[] = &quot;demo_topic&quot;;// 创建一个 Subscriber 对象const ros::Subscriber &amp;sub = node.subscribe(topic_name, 1000, subCallback); 创建回调函数 1234void subCallback(const demo_msgs::Team::ConstPtr &amp;msg) &#123; // 一般写业务逻辑，此处打印接收到的数据 ROS_INFO_STREAM(msg-&gt;name);&#125; 编译该节点，在工作空间目录下 1catkin_make python版本 在 package 目录下创建一个名为 scripts 的文件夹 创建一个名为 subscriber1.py 的文件，将以下代码添加到该文件中 1234567891011121314#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyif __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_subscriber&quot; # 初始化 ros 节点 rospy.init_node(node_name) # todo 将业务逻辑写在此处 # 开启 ros 运行时循环 rospy.spin() 创建 Subscriber 对象 导入要订阅的消息的头文件 1from demo_msgs.msg import Team 创建对象，并订阅消息 1234# 创建一个 topic 名称topic_name = &quot;demo_topic&quot;# 创建一个 Subscriber 对象sub = rospy.Subscriber(topic_name, Team, subCallback) 创建回调函数 1234# 注意这个赋默认值是为了使后面有代码提示，实际过程中，msg 被传入的，所以不影响结果def subCallback(msg=Team()): # 一般写业务逻辑，此处打印接收到的数据 print (msg.name) 给 subscriber.py 赋予可执行权限 1chmod a+x src/demo_topic/scripts/subscriber1.py 使用 rqt_publisher 工具调试 将当前工作空间的环境变量添加到bash或zsh中 123# 根据使用不同的 shell 使用不同的环境变量，两者选其一source devel/setup.bash # 使用 bashsource devel/setup.zsh # 使用 zsh 运行 demo_publisher c++ 程序 1rosrun demo_topic demo_subscriber python 程序 1rosrun demo_topic subscriber.py 打开 rqt_publisher 工具 1rosrun rqt_publisher rqt_publisher 选择我们对应的Topic：demo_topic，Type选择demo_msgs/Team 勾选就会一直发送数据，或者右键点击Publisher Selected Once 可以发送一次数据 总结 两种订阅消息几乎是一样的，因为在我们创建包的时候已经将std_msgs的依赖导入了，所以导致我们就不需要添加依赖。 使用对应消息的时候要添加对应消息的依赖。 回调函数默认在主线程中进行，即ros::spin()或rospy.spin()会卡死主线程，进入ros的运行时 如果有别的运行时，如 qt(以后会详细介绍qt中的用法)，则需要使用异步接收ros的运行时消息，或者在 qt 中使用spinOnce()(仅在c++中需要) 代码块C++ros_create_subscriber12345678910111213141516&quot;ros_create_subscriber&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_subscriber&quot;, &quot;body&quot;: [ &quot;#include \\&quot;$&#123;1: topic_class&#125;\\&quot;&quot;, &quot;&quot;, &quot;void callback(const $&#123;2: topic_class&#125;::ConstPtr &amp;msg) &#123;&quot;, &quot; // 一般写业务逻辑，此处打印接收到的数据&quot;, &quot; ROS_INFO_STREAM(msg);&quot;, &quot;&#125;&quot;, &quot;// 创建一个 topic 的名称&quot;, &quot;// todo 填写 topic 名称&quot;, &quot;char topic_name[] = \\&quot;$&#123;3&#125;\\&quot;;&quot;, &quot;// 创建一个 Subscriber 对象&quot;, &quot;const ros::Subscriber &amp;sub = node.subscribe(topic_name, 1000, callback);&quot;, ] &#125; Pythonros_create_subscriber12345678910111213141516171819&quot;ros_create_subscriber&quot;: &#123; &quot;prefix&quot;: &quot;ros_create_subscriber&quot;, &quot;body&quot;: [ &quot;# todo 填写 msg 的类型&quot;, &quot;from $&#123;1: msg_class&#125;.msg import $&#123;2: msg_type&#125;&quot;, &quot;&quot;, &quot;&quot;, &quot;def subCallback(msg=$&#123;2:msg_type&#125;()):&quot;, &quot; # 一般写业务逻辑，此处打印接收到的数据&quot;, &quot; print (msg)&quot;, &quot;&quot;, &quot;&quot;, &quot;# 创建一个 topic 名称&quot;, &quot;# todo 填写 topic 名称&quot;, &quot;topic_name = \\&quot;$&#123;3: topic_name&#125;\\&quot;&quot;, &quot;# 创建一个 Subscriber 对象&quot;, &quot;sub = rospy.Subscriber(topic_name, $&#123;2: msg_type&#125;, subCallback)&quot;, ], &#125; 附录创建只发布std消息的节点的完整代码C++123456789101112131415161718192021222324#include &quot;std_msgs/String.h&quot;// 导入 ros 头文件#include &lt;ros/ros.h&gt;void subCallback(const std_msgs::String::ConstPtr &amp;msg) &#123; // 一般写业务逻辑，此处打印接收到的数据 ROS_INFO_STREAM(msg-&gt;data);&#125;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_subscriber&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建一个 topic 的名称 char topic_name[] = &quot;demo_topic&quot;; // 创建一个 Subscriber 对象 const ros::Subscriber &amp;sub = node.subscribe(topic_name, 1000, subCallback); // 进入一个简单的事件循环 ros::spin(); return 0;&#125; Python12345678910111213141516171819202122232425#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom std_msgs.msg import Stringdef subCallback(msg=String()): # 一般写业务逻辑，此处打印接收到的数据 print (msg.data)if __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_subscriber&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建一个 topic 名称 topic_name = &quot;demo_topic&quot; # 创建一个 Subscriber 对象 sub = rospy.Subscriber(topic_name, String, subCallback) # 开启 ros 运行时循环 rospy.spin() 创建发布自定义消息的节点C++123456789101112131415161718192021222324#include &quot;demo_msgs/Team.h&quot;// 导入 ros 头文件#include &lt;ros/ros.h&gt;void subCallback(const demo_msgs::Team::ConstPtr &amp;msg) &#123; // 一般写业务逻辑，此处打印接收到的数据 ROS_INFO_STREAM(msg-&gt;name);&#125;int main(int argc, char **argv) &#123; // 创建 ros 的节点名称 char node_name[] = &quot;demo_subscriber&quot;; // 初始化 ros 节点 ros::init(argc, argv, node_name); // 创建一个节点对象 ros::NodeHandle node; // 创建一个 topic 的名称 char topic_name[] = &quot;demo_topic&quot;; // 创建一个 Subscriber 对象 const ros::Subscriber &amp;sub = node.subscribe(topic_name, 1000, subCallback); // 开启 ros 的运行时循环 ros::spin(); return 0;&#125; Python12345678910111213141516171819202122232425#!/usr/bin/env python# coding: utf-8# 导入 rospy 依赖import rospyfrom demo_msgs.msg import Teamdef subCallback(msg=Team()): # 一般写业务逻辑，此处打印接收到的数据 print (msg.name)if __name__ == &quot;__main__&quot;: # 节点名称 node_name = &quot;demo_subscriber&quot; # 初始化 ros 节点 rospy.init_node(node_name) # 创建一个 topic 名称 topic_name = &quot;demo_topic&quot; # 创建一个 Subscriber 对象 sub = rospy.Subscriber(topic_name, Team, subCallback) # 开启 ros 运行时循环 rospy.spin()","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS Topic","slug":"ROS-Topic","permalink":"https://askeynil.github.io/tags/ROS-Topic/"}]},{"title":"ROS 命令行工具介绍","slug":"ROS 命令行工具介绍","date":"2019-10-18T02:00:00.000Z","updated":"2020-11-04T10:55:07.304Z","comments":true,"path":"2019/412acdc0.html","link":"","permalink":"https://askeynil.github.io/2019/412acdc0.html","excerpt":"","text":"命令 解释 roscore 用来开启ros master rosnode 用来打印节点信息 rosrun 用来运行节点 rosmsg 用来显示 msg 数据 rossrv 用来显示 srv 数据","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS command","slug":"ROS-command","permalink":"https://askeynil.github.io/tags/ROS-command/"},{"name":"Shell","slug":"Shell","permalink":"https://askeynil.github.io/tags/Shell/"}]},{"title":"ROS 概述","slug":"ROS 概述","date":"2019-10-18T02:00:00.000Z","updated":"2019-10-18T02:00:00.000Z","comments":true,"path":"2019/ROS-Overview.html","link":"","permalink":"https://askeynil.github.io/2019/ROS-Overview.html","excerpt":"ros的基础架构 ROS 项目在部署运行的过程中，大致分为4个部分： 环境 软件环境 硬件环境 执行器 给操作系统发送一些指令，以此来控制硬件执行相应操作 传感器 传感器接收外部环境给的输出，反馈给相应的软件 软件结构 ros 一个可执行程序，就是一个节点 ros master用来管理各个节点","text":"ros的基础架构 ROS 项目在部署运行的过程中，大致分为4个部分： 环境 软件环境 硬件环境 执行器 给操作系统发送一些指令，以此来控制硬件执行相应操作 传感器 传感器接收外部环境给的输出，反馈给相应的软件 软件结构 ros 一个可执行程序，就是一个节点 ros master用来管理各个节点 软件结构的组成 ROS Master 管理每个节点间的通信 每个节点都需要到 ROS Master 中进行注册 通过roscore命令启动ROS Master，而且在节点开始前必须启动ROS Master ROS Node 具备单一的功能的可执行程序 可以单独编译，可执行，可管理 存放在package中 一个节点就是一个可执行程序 ros客户端库ROS 客户端允许使用不同的编程语言编写的节点之间相互通信 rospy = python 客户端库 roscpp = c++ 客户端库 使用 rosnode1234567891011121314151617181920$ rosnode -h---# rosnode 是一个用来打印 ROS 节点信息的命令行工具rosnode is a command-line tool for printing information about ROS Nodes.Commands: # 测试是否能连接到节点 rosnode ping test connectivity to node # 激活的节点列表 rosnode list list active nodes # 打印节点信息 rosnode info print information about node # 列出在特定计算机上运行的节点 rosnode machine list nodes running on a particular machine or list machines # 杀死正在运行的节点 rosnode kill kill a running node # 清除不可达的的节点的注册信息（ping不通，就是程序死掉了，信息没删掉） rosnode cleanup purge registration information of unreachable nodes#输入 rosnode &lt;command&gt; -h 以获得更多使用说明，例如 rosnode ping -hType rosnode &lt;command&gt; -h for more detailed usage, e.g. &#x27;rosnode ping -h&#x27;` 通过 -h 可以快速查询对应的命令和用法，这里只提取常用的 常用方法 runnode list 查看当前开启的节点 rosnode info [node] 查看节点的信息 rosnode cleanup 清除无用的节点信息 使用 rosrun1234567$ rosrun -h---Usage: rosrun [--prefix cmd] [--debug] PACKAGE EXECUTABLE [ARGS] rosrun will locate PACKAGE and try to find an executable named EXECUTABLE in the PACKAGE tree. If it finds it, it will run it with ARGS.# rosrun 试图找到 PACKAGE 和 PACKAGE 下的名为 EXECUTABLE 的可执行程序。如果找到，将参数args传入并运行它 一般该命令在输入 package 和 executable 的时候使用 tab 键都会有提示，如果没有提示，尝试source 当前工作空间下 devel/setup.bash 或 devel/setup.zsh(如果你用zsh的话) 注意：如果写python程序，需要给 python 的入口python文件一个可执行的权限，例如： 1chmod a+x main.py","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS command","slug":"ROS-command","permalink":"https://askeynil.github.io/tags/ROS-command/"},{"name":"Shell","slug":"Shell","permalink":"https://askeynil.github.io/tags/Shell/"}]},{"title":"Vim 整理","slug":"Vim 整理","date":"2019-10-15T14:00:00.000Z","updated":"2019-10-25T00:00:00.000Z","comments":true,"path":"2019/b1cfc668.html","link":"","permalink":"https://askeynil.github.io/2019/b1cfc668.html","excerpt":"因经常需要在 Ubuntu 和 Mac OS 端进行转换，编辑器中快捷键不对应，甚至说一些快捷键找不到好的替代，故编辑器界面改用 Vim，以两端使用同一快捷键。此文整理常用 Vim 命令，不定时更新。 光标操作移动光标键 h j k l 左 下 上 右 命令模式下 当前行移动光标 命令 解释 0 移动到行头 $ 移动到行尾 ^ 移动到本行第一个不是 black 的字符位置 g_ 移动到本行最后一个不是 black 的字符位置 w 移动到下一个单词的开头 e 移动到下一个单词的结尾 fa 移动到本行下一个为 a 的字符处，a可以为任意字符 nfa 移动到本行下 n(1,2,3,4) 个字符为 a 的地方 Fa 跟 fa 一样，反向相反 nFa 很 nfa一样，反向相反 ta 移动到本行下一个光标为 a 字符的前一个位置 nta 移动到本行下 n(1,2,34)个字符为 a 的前一个位置 Ta 跟 ta 一样，反向相反 nTa 很 nta一样，反向相反","text":"因经常需要在 Ubuntu 和 Mac OS 端进行转换，编辑器中快捷键不对应，甚至说一些快捷键找不到好的替代，故编辑器界面改用 Vim，以两端使用同一快捷键。此文整理常用 Vim 命令，不定时更新。 光标操作移动光标键 h j k l 左 下 上 右 命令模式下 当前行移动光标 命令 解释 0 移动到行头 $ 移动到行尾 ^ 移动到本行第一个不是 black 的字符位置 g_ 移动到本行最后一个不是 black 的字符位置 w 移动到下一个单词的开头 e 移动到下一个单词的结尾 fa 移动到本行下一个为 a 的字符处，a可以为任意字符 nfa 移动到本行下 n(1,2,3,4) 个字符为 a 的地方 Fa 跟 fa 一样，反向相反 nFa 很 nfa一样，反向相反 ta 移动到本行下一个光标为 a 字符的前一个位置 nta 移动到本行下 n(1,2,34)个字符为 a 的前一个位置 Ta 跟 ta 一样，反向相反 nTa 很 nta一样，反向相反 跨行移动光标 命令 解释 nG 光标定位到第 n 行的行首 gg 光标定位到第一行的行首 G 光标定位到最后一行的行首 % 匹配括号移动，包括(,&#123;,[需要把光标先移动到括号上 * 匹配下一个光标当前所在的单词 # 匹配上一个光标当前所在的单词 ctrl+f 查看下一页 ctrl+b 查看上一页 复制，粘贴，剪切(删除)只要记住三个重要的按键y(复制)，p(粘贴)，d(剪切，删除)，通常都会在配合一个按键使用。 复制 命令 解释 yw 复制一个单词 ynw 复制 n 个单词 yfa 复制光标处到下一个 a 的字符处 ynfa 复制光标处到第 n 个 a 的字符处 yd 复制一整行 nyy 复制 n 行 y$ 从光标处复制到本行末尾 yH 复制屏幕显示的第一行文本到光标处所在的行 yG 复制光标所在位置到文本结束位置所有的行 粘贴 命令 解释 p 在光标后粘贴 P 大写的 P 的在光标前粘贴 删除 命令 解释 dw 删除一个单词 dnw 删除 n 个单词 dfa 删除光标处到下一个 a 的字符处 dnfa 删除光标处到第 n 个 a 的字符处 dd 删除一整行 ndd 删除 n 行 d$ 从光标处删除到本行末尾 dH 删除屏幕显示的第一行文本到光标处所在的行 dG 删除光标所在位置到文本结束位置所有的行 撤销 命令 解释 u 撤销刚才的操作 ctrl + r 恢复撤销的操作 删除字符和替换 命令 解释 x 删除当前光标所在的字符 r 替换当前光标所在的字符 R 替换模式 复制、剪切和粘贴到系统剪切板 命令 解释 :reg 查看寄存器 &quot; +(寄存器名) y/d/p 复制，剪切，粘贴 一般系统的剪切板的寄存器名称为 + 。 命令用中文描述为：双引号 + 寄存器名 + 执行的命令（y、d、p） 如果仅仅针对系统剪切板则应该执行的命令是&quot;+y、&quot;+d、&quot;+p 可视化模式 命令 解释 v 字符可视化 V 行可视化 ctrl + v 块可视化 可视化模式下操作 命令 解释 y 复制选中区域 d 删除，剪切选中区域 p 粘贴选中区域 r 替换选中的文本 gu 选中区域转小写 gU 选中区域转大写 g~ 选中区域大小写互转 &gt; 向右缩进一个单位 &lt; 向左缩进一个单位 可视化模式v的特殊操作 以下符号只包括””,’’,(),[],{}（双引号 ，单引号，小括号，中括号，大括号），不能匹配中文的对应符号。 命令 解释 v + i + 符号 匹配对应符号包裹的内容，不包括符号 v + a + 符号 匹配对应符号包裹的内容，包括符号 块区域模式的特殊操作使用 Ctrl + v 选中区域后，可使用如下命令插入数据 命令 解释 I 选中区域前面插入数据 A 选中区域后面插入数据 打开文件 打开单个文件 1vim file 打开多个文件 1vim file1 file2 ... 使用这种方式打开文件，显示屏上默认只会出现 file1 这一个文件 切换到命令模式，使用 :ls 查看当前打开的所有文件，使用:bn切换到第 n 个文件，比如切换到第二个文件就是b2 一个显示屏多开文件 123456# 打开几个文件就分屏几个文件# 左右分屏打开vim -On file1 file2 ... filen# 上下分屏打开vim -on file1 file2 ... filen vim 分屏 按住 Ctrl + w，然后在按下 s：ctrl + w s，当前文件上下分割 按住 Ctrl + w，然后在按下 v：ctrl + w v，当前文件左右分割 :sp file ：新建文件上下分割 :vsp file ：新建文件左右分割 移动光标 按住 Ctrl + w，然后加位移键（hjkl 或上下左右）移动到对应位置 关闭分屏 按住 Ctrl + w，然后按 c，关闭当前分屏 按住 Ctrl + w，然后按 q，关闭当前分屏，如果是最后一个则退出 Vim 文件I/O操作 以下均在命令模式下 命令 解释 :w 保存当前对文件，但是不退出文件 :w! 强制保存当前的文件，但是不退出文件 :w file 保存当前文件到 file 文件中，不打开 file :q 退出文件 :q! 强制退出文件，对文件的修改不保存 :qa! 强制退出所有文件，对所有文件的修改不保存 :wq 保存文件，并退出 :x 保存文件，并退出 :e file 打开 另一个文件 :e! 放弃对文件的所有修改，恢复文件到上次保存的位置 :saveas file 另存为 file，并打开 file :n flie 新建一个文件，名字为 file ls 命令（vscode 中么有用）ls可以显示当前打开的所有文件，与终端中的 ls意义类似，例如： 1234:ls 1 # &quot;demo1.py&quot; 第 1 行 2 %a &quot;demo2.py&quot; 第 1 行 3 &quot;demo3.py&quot; 第 1 行 第一列，代表文件的id，可根据此 id 跳转到该文件 第二列，%a的%当前光标所在文件，a表示当前打开的文件，如果打开多个就会有多个 a，#代表上一个打开的文件。 第三列，打开的文件名称，如果有/则表示路径。 第四列，光标所在的行数。 切换文件命令 命令 解释 :bn 切换下一个文件 :bp 切换上一个文件 :b1 切换 id 为 1 的文件，其它 id 同理。 :b# 切换上一个编辑的文件 编辑模式 命令 解释 i 在光标所在位置之前插入文本 I 在光标所在行的行首插入文本 a 在光标所在位置之后插入文本 A 在光标所在行的行尾插入文本 o 在光标所在位置的下一行插入新行，并插入文本 O 在光标所在位置的上一行插入新行，并插入文本 s 删除光标所在处的字符然后插入本文 S 删除光标所在行，并在行首插入文本 cw 删除光标所在处到单词结束的所有字符，并插入文本。 文本替换vim中文本替换的规则如下： :&#123;作用范围&#125;s/&#123;目标&#125;/&#123;替换&#125;/&#123;替换的标志&#125; 作用范围：当前行，全文，选区 替换的标志：g(全局替换标志)，空替换标志，i大小写不敏感查找，I大小写敏感查找，c需要确认替换 🌰（例子）： 将光标所在行的 demo 替换为 temp 1:s/demo/temp/g 将全文中的所有 demo 替换为temp 1:%s/demo/temp/g 将行号 n1到 n2 的所有 demo 替换为 temp 12:n1,n2s/demo/temp/g# 注意这里的 n1,n2 之间不能有空格 选择区域，在可视模式下选择区域，然后输入:，vim 会自动补全&#39;&lt;,&#39;&gt; 1:&#x27;&lt;,&#x27;&gt;s/demo/temp/g 在全文中查找所有 demo 但是只替换第一个 demo为temp 1:%s/demo/temp 等等…用好常用的标识符即可，g, 空, i, I, c。 其他常用命令 命令 解释 :n 定位到第 n 行 /匹配的字符串 关键字查找，n 查看下一个, N 查看上一个 :set ic(noic) 设置不区分大小写（区分大小写），编辑器默认不区分大小写 :n1,n2d 删除 n1 行到 n2 行的文本","categories":[{"name":"Editor","slug":"Editor","permalink":"https://askeynil.github.io/categories/Editor/"},{"name":"Vim","slug":"Editor/Vim","permalink":"https://askeynil.github.io/categories/Editor/Vim/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://askeynil.github.io/tags/Vim/"}]},{"title":"ROS 消息（msg）和服务（srv）","slug":"ROS 消息（msg）和服务（srv）","date":"2019-10-15T12:00:00.000Z","updated":"2019-10-18T23:00:00.000Z","comments":true,"path":"2019/ros-msg-srv.html","link":"","permalink":"https://askeynil.github.io/2019/ros-msg-srv.html","excerpt":"消息（msg）和服务（srv）总览 消息（msg）就是一个描述 ROS 中所使用的消息类型的简单文本，后缀以.msg命名。 服务（srv）就是一个描述 ROS 服务数据的文本，后缀以.srv 命名。它包含两个部分：request 和 response msg文件存放在 package 目录的 msg 目录下，srv 文件存放在 package 目录的 srv 目录下。","text":"消息（msg）和服务（srv）总览 消息（msg）就是一个描述 ROS 中所使用的消息类型的简单文本，后缀以.msg命名。 服务（srv）就是一个描述 ROS 服务数据的文本，后缀以.srv 命名。它包含两个部分：request 和 response msg文件存放在 package 目录的 msg 目录下，srv 文件存放在 package 目录的 srv 目录下。 msg 文件实际上就是每行声明一个数据类型和变量名，它们可以使用的数据类型如下： 内置类型 原始类型 c++ Python2 Python3 bool uint8_t bool bool int8 int8_t int int uint8 uint8_t int int int16 int16_t int int uint16 uint16_t int int int32 int32_t int int uint32 uint32_t int int int64 int64_t long int uint64 uint64_t long int float32 float float float float64 double float float string std::string str bytes time ros::Time rospy.Time rospy.Time duration ros::Duration rospy::Duration rospy::Duration 注意： uint8 在Python中具有特殊含义。uint8[]被视为Python 的 bytes，因此它可以被其他面向 Python bytes 的 api 兼容。 当前不支持将 Unicode 字符串作为 ROS 的数据类型，utf-8 应该用于与 ROS 字符串序列化兼容。在 Python2中，这种编码对于 Unicode 是自动的，但是解码必须手动完成。在 Python3 中，当使用 str 时，在生成的消息代码中使用&#39;utf-8&#39;进行编码和解码。 数组类型 原始数据 C++ Python2 Python3 定长数组 boost::array&lt;T, length&gt; tuple tuple 可变长数组 std::vector&lt;T&gt; tuple tuple uint8[] std::vector&lt;unit8_t&gt; str bytes bool[] std::vector&lt;uint8_t&gt; list of bool list of bool 其他 msg 文件类型 其他自定义类型，类似于系统中的std_msgs/String，或者自定义之前写好的类型，下面会做更详细的介绍。 在 ros 中还有一种特殊的数据类型Header，它含有时间戳和坐标系信息。在 msg 文件的第一行经常可以看到Header header的声明。 样例msg 样例下面是一个 msg 文件的样例，它使用了 Header、string 和两个自定义msg类型 1234Header headerstring child_frame_idgeometry_msgs&#x2F;PoseWithCovariance posegeometry_msgs&#x2F;TwistWithCovariance twist srv样例srv 文件分为 request 和 response 两部分，用---分隔开。 1234int64 Aint64 B---int64 Sum 其中 A 和 B 是 request 部分，而 Sum是 response 部分 下面详细介绍两种消息类型的创建，你也可以直接到总结中看两种消息的差异点 msg 消息创建一个简单 msg 消息 首先来到 package 目录下，创建msg目录 新建一个 Student.msg 文件 添加数据格式 12string nameint64 age 配置 package.xml 文件，添加如下代码 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 配置 CMakeLists.txt 在 find_package 中添加 message_generation 123456find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy message_generation) 添加 add_messgae_file 12345# 添加 msg 文件add_message_files( FILES Student.msg # 该名称就是你创建的 msg 文件的名称) 添加 generation_msg 12345# 用于添加生成消息所需的依赖generate_messages( DEPENDENCIES std_msgs # 默认添加 std_msgs) 在 catkin_package中添加CATKIN_DEPENDS message_runtime 123456789# catkin 所需依赖catkin_package( # INCLUDE_DIRS include # LIBRARIES demo_msg # CATKIN_DEPENDS roscpp rosmsg rospy # DEPENDS system_lib # 为 catkin 添加 message_runtime 依赖 CATKIN_DEPENDS message_runtime) 来到 workspace目录，使用命令 catkin_make 编译即可。 在 devel 的include目录下，如果生成了头文件，则说明创建成功。 自定义 Obj 消息 步骤与简单消息大致相同，这里只列出不同的地方 新建 Team.msg 文件 12string nameStudent leader 配置 CMakeLists.txt 添加 add_message_file 1234567add_message_files( FILES Student.msg Team.msg)# Team.msg 为创建的自定义 obj 消息，文件必须在 msg 目录下# 由于 Team.msg 引用了 Student.msg，将 Student.msg 放在靠前的位置。 引用第三方库的消息 修改 Team.msg 123string nameStudent leadergeometry_msgs&#x2F;Twist location 修改 package.xml 文件 123&lt;build_depend&gt;geometry_msgs&lt;/build_depend&gt;&lt;build_export_depend&gt;geometry_msgs&lt;/build_export_depend&gt;&lt;exec_depend&gt;geometry_msgs&lt;/exec_depend&gt; 或 1&lt;depend&gt;geometry_msgs&lt;/depend&gt; 修改 CMakeLists.txt 在 find_package 中添加geometry_msgs 1234567find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy message_generation geometry_msgs) 在 generate_messages中添加geometry_msgs 12345generate_messages( DEPENDENCIES std_msgs geometry_msgs) 使用rosmsg在终端使用： 1rosmsg show (package_name)/(msg_name) package_name：对应的包名称 msg_name：对应的消息名称 当前的例子使用的命令为： 1rosmsg show demo_msgs/Student 终端打印为： 12string nameint64 age rosmsg的更多用法在下面介绍 srv 消息创建一个简单的 srv 消息 首先来到 package 目录下，创建 srv 目录 新建一个 NumOption.srv 文件 添加数据 12345float64 afloat64 bstring option---float64 result 配置 package.xml 文件，添加如下代码 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 配置 CMakeLists.txt 在 find_package 中添加 message_generation 123456find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy message_generation) 添加 add_service_files 12345# 添加 srv 文件add_service_files( FILES NumOption.srv # 该名称就是你创建的 srv 文件的名称) 添加 generation_msg 12345# 用于添加生成消息所需的依赖generate_messages( DEPENDENCIES std_msgs # 默认添加 std_msgs) 在 catkin_package中添加CATKIN_DEPENDS message_runtime 123456789# catkin 所需依赖catkin_package( # INCLUDE_DIRS include # LIBRARIES demo_msg # CATKIN_DEPENDS roscpp rosmsg rospy # DEPENDS system_lib # 为 catkin 添加 message_runtime 依赖 CATKIN_DEPENDS message_runtime) 来到 workspace目录，使用命令 catkin_make 编译即可。 在 devel 的include目录下，如果生成了头文件，则说明创建成功。 自定义复杂类型 srv 消息 步骤与简单 srv 消息大致相同，这里只列出不同的地方 首先来到 package 目录下，创建 srv 目录 新建一个 FindTeam.srv 文件 添加数据 123Student student---Team team 配置 package.xml 文件，添加如下代码 123456&lt;build_depend&gt;demo_msgs&lt;/build_depend&gt;&lt;build_export_depend&gt;demo_msgs&lt;/build_export_depend&gt;&lt;exec_depend&gt;demo_msgs&lt;/exec_depend&gt;&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 或 1234&lt;depend&gt;demo_msgs&lt;/depend&gt;&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 配置 CMakeLists.txt 在 find_package 中添加 message_generation 1234567find_package(catkin REQUIRED COMPONENTS roscpp rosmsg rospy message_generation demo_msgs) 添加 add_service_files 123456# 添加 srv 文件add_service_files( FILES NumOption.srv # 该名称就是你创建的 srv 文件的名称 FindTeam.srv) 添加 generation_msg 123456# 用于添加生成消息所需的依赖generate_messages( DEPENDENCIES std_msgs # 默认添加 std_msgs demo_msgs) 来到 workspace目录，使用命令 catkin_make 编译即可。 在 devel 的include目录下，如果生成了头文件，则说明创建成功。 使用rossrv在终端使用： 1rosmsg show (package_name)/(srv_name) package_name：对应的包名称 srv_name：对应的消息名称 当前的例子使用的命令为： 1rossrv show demo_srvs/NumOption 终端打印为： 12345float64 afloat64 bstring option---float64 result rossrv的更多用法在下面介绍 总结差别 msg 消息要放在package的 msg 文件夹下，而srv消息则放到package的srv文件夹下。 msg消息的后缀是msg，srv消息的后缀是srv。 msg消息的内容无需使用---分割，而srv消息内容需要使用---分割，上半部分是request消息，而下半部分是response消息 msg消息需要添加到add_message_files中，以Student.msg为例。 12345add_message_files( FILES ... # 这里是你的其他消息 Student.msg # 该名称就是你创建的 msg 文件的名称) srv消息需要添加到add_service_files中，以NumOption.srv为例 123456# 添加 srv 文件add_service_files( FILES ... # 这里是你的其他消息 NumOption.srv # 该名称就是你创建的 srv 文件的名称) msg消息使用rosmsg查看数据，srv消息使用rossrv查看数据。 共同点 都需要在package.xml中添加如下两行代码 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 引用其他package中的消息都需要在package.xml和CMakeLists.txt中添加依赖，以下以Demo_msgs为例 package.xml 123&lt;build_depend&gt;demo_msgs&lt;/build_depend&gt;&lt;build_export_depend&gt;demo_msgs&lt;/build_export_depend&gt;&lt;exec_depend&gt;demo_msgs&lt;/exec_depend&gt; CMakeLists.txt 12345678910find_package(catkin REQUIRED COMPONENTS ... # 这里是你其他的依赖 demo_msgs )generate_messages( DEPENDENCIES ... # 这里是你其他的依赖 demo_msgs) 都需要在CMakeLists.txt文件中添加message_generation，CATKIN_DEPENDS message_runtime 123456789find_package(catkin REQUIRED COMPONENTS ... # 这里是你其他的依赖 message_generation )catkin_package( ... # 这里是你其他的依赖 CATKIN_DEPENDS message_runtime) 生成的头文件都在对应的 devel 的 include 目录 msg 和 srv 调试工具rosmsg1234567891011121314151617181920$ rosmsg -h----# rosmsg 是一个用来显示 ROS 消息类型的命令行工具rosmsg is a command-line tool for displaying information about ROS Message types.# 命令Commands: # rosmsg show: 显示消息描述 rosmsg show Show message description # rosmsg info: show 的别名 rosmsg info Alias for rosmsg show # rosmsg list: 所有消息列表 rosmsg list List all messages # rosmsg md5: 显示消息 md5 值 rosmsg md5 Display message md5sum # rosmsg package: 包中的消息列表 rosmsg package List messages in a package # rosmsg packages: 显示所有 msg 的包名 rosmsg packages List packages that contain messages# 使用 rosmsg &lt;command&gt; -h 获取更多的帮助Type rosmsg &lt;command&gt; -h for more detailed usage show/info123456789101112131415$ rosmsg show -h----# 使用方法：rosmsg show [options] &lt;message type&gt;Usage: rosmsg show [options] &lt;message type&gt;# 可选参数Options: # -h, --help 显示帮助消息，并退出 -h, --help show this help message and exit # -r, --raw 显示原始消息文本，包括注释。 -r, --raw show raw message text, including comments # -b BAGFILE, --bag=BAGFILE -b BAGFILE, --bag=BAGFILE # 从.bag 文件中显示消息 show message from .bag file Demo123456$ rosmsg show -r turtle_actionlib/Velocity----# Copied from turtlesim https://github.com/ros/ros_tutorials/blob/f7da7779e82dcc3977b2c220a843cd86dd269832/turtlesim/msg/Velocity.msg. We had to copy this into this package since it has been replaced with geometry_msgs/Twist there and comforming to Twist requires to change code, which I doubt worth time it takes. So if you think it is, please go ahead make a patch.float32 linearfloat32 angular 1234$ rosmsg show turtle_actionlib/Velocity----float32 linearfloat32 angular list123456789101112131415$ rosmsg list---- # 选取最后几行的数据turtlesim/Colorturtlesim/Posevisualization_msgs/ImageMarkervisualization_msgs/InteractiveMarkervisualization_msgs/InteractiveMarkerControlvisualization_msgs/InteractiveMarkerFeedbackvisualization_msgs/InteractiveMarkerInitvisualization_msgs/InteractiveMarkerPosevisualization_msgs/InteractiveMarkerUpdatevisualization_msgs/Markervisualization_msgs/MarkerArrayvisualization_msgs/MenuEntry md512# 使用方式 rosmsg md5 &lt;message type&gt;Usage: rosmsg md5 &lt;message type&gt; Demo123$ rosmsg md5 std_msgs/String----992ce8a1687cec8c8bd883ec73ca41d1 package12345678$ rosmsg package -h---Usage: rosmsg package &lt;package&gt;Options: -h, --help show this help message and exit # -s 所有的消息都显示在一行 -s list all msgs on a single line Demo123$ rosmsg package -s turtlesim---turtlesim/Color turtlesim/Pose 1234$ rosmsg package turtlesim---turtlesim/Colorturtlesim/Pose packages12345678910$ rosmsg packages---# 选取了最后几行数据tftf2_msgstheora_image_transporttrajectory_msgsturtle_actionlibturtlesimvisualization_msgs rossrvrossrv 的命令和 rosmsg 的命令除了显示的数据是 srv 以外其他都是一模一样的，参考上方的 rosmsg 即可","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"ROS msg","slug":"ROS-msg","permalink":"https://askeynil.github.io/tags/ROS-msg/"},{"name":"ROS srv","slug":"ROS-srv","permalink":"https://askeynil.github.io/tags/ROS-srv/"}]},{"title":"CMakeLists.txt 详解","slug":"CMakeLists.txt 详解","date":"2019-10-15T08:30:00.000Z","updated":"2020-11-04T10:55:07.300Z","comments":true,"path":"2019/8070dad1.html","link":"","permalink":"https://askeynil.github.io/2019/8070dad1.html","excerpt":"修改自 ros 官方 wiki http://wiki.ros.org/catkin/CMakeLists.txt CMakeLists.txt 是 CMake 构建系统的输入，用于构建软件包。catkin 的 CMakeLists.txt 带有一些其它的约束 总体结构 所需的 CMake 版本。（ cmake_minimum_required ） 包名称。（ project ） 查找构建所需的 CMake或 Catkin 软件包。（ find_package ） 启动 Python 模块支持。（ catkin_python_setup ） 消息、服务、动作生成器。（ add_message_files，add_service_files，add_action_files ） 调用消息、服务、动作生成。（ generate_messages ） 指定包构建信息导出。（ catkin_package ） 添加要构建的库或可执行文件。（ add_library，add_executable，target_link_libraries ） 测试构建。（ catkin_add_gtest ） 安装规则。（ install ）","text":"修改自 ros 官方 wiki http://wiki.ros.org/catkin/CMakeLists.txt CMakeLists.txt 是 CMake 构建系统的输入，用于构建软件包。catkin 的 CMakeLists.txt 带有一些其它的约束 总体结构 所需的 CMake 版本。（ cmake_minimum_required ） 包名称。（ project ） 查找构建所需的 CMake或 Catkin 软件包。（ find_package ） 启动 Python 模块支持。（ catkin_python_setup ） 消息、服务、动作生成器。（ add_message_files，add_service_files，add_action_files ） 调用消息、服务、动作生成。（ generate_messages ） 指定包构建信息导出。（ catkin_package ） 添加要构建的库或可执行文件。（ add_library，add_executable，target_link_libraries ） 测试构建。（ catkin_add_gtest ） 安装规则。（ install ） CMake 版本每个 catkin CMakeLists.txt 文件必须以所需的 CMake 版本开头。Catkin 需要的版本是 2.8.3 或更高 1cmake_minimum_required(VERSION 2.8.3) 包名必须指定其包名称。假设我们正在制作一个名为 hello_ros 的包。 1project(hello_ros) 注意：在 CMake 中，可以在以后任意需要的地方使用变量$&#123;PROJECT_NAME&#125;在 CMake 脚本中的任何位置应用项目名称。 查找依赖的 CMake 软件包我们需要使用 find_package 函数来指定找到哪些其他 CMake 软件包来构建我们的项目。Catkin 至少需要一个依赖 1find_package(catkin REQUIRED) 术语： wet packages（湿包），用 Catkin 构建的包 dry packages（干包），用 rosbuild 构建的包 如果项目依赖于其他的湿包，则可以将这些包指定为组件，而不是在这些包上使用 find_package，它使工作更加的轻松。例如使用了 roscpp 1234find_package( catkin REQUIRED COMPONENTS roscpp) 也可以 12find_package(catkin REQUIRED)find_package(roscpp REQUIRED) 显然，第一种方式更为方便 find_package() 有什么作用如果 CMake通过 find_package() 找到一个包，它会自动创建几个 CMake 的环境变量，这些变量提供有关找到的包的信息。这些环境变量可以在稍后的 CMake 脚本中使用。这些环境变量描述了软件包导出的头文件在哪里，源文件在哪里，软件包所依赖的库以及这些库的路径。名称始终遵循&lt;PACKAGE NAME&gt;_&lt;PROPERTY&gt;的约定： &lt;NAME&gt;_FOUND，如果找到该值为 true，否则为 false &lt;NAME&gt;_INCLUDE_DIRS 或&lt;NAME&gt;_INCLUDES，包导出的包含路径 &lt;NAME&gt;_LIBRARIES或&lt;NAME&gt;_LIBS，包导出的库 &lt;NAME&gt;_DEFINITIONS 为什么将 Catkin 包指定为组件（COMPONENTS）Catkin 包在 Cakin 中并不是真正的组件，但是在 Catkin 设计中利用了 CMake 这个组件功能，以节省大量的编辑时间。 对于catkin包，如果将find_package用作catkin的组件，则这是有利的，因为使用catkin_前缀创建了一组环境变量。 catkin_package()catkin_package()是 catkin 提供的 CMake 宏。这是向构建系统指定特定于 Catkin 的信息所必需的，而构建系统又将其用于生成 pkg-config 和 CMake 文件 必须在使用add_library()和add_executable()声明任何目标之前调用此函数。 该函数具有 5 个可选参数： INCLUDE_DIRS：导出包的包含路径 LIBRARIES：项目中导出的库 CATKIN_DEPENDS：此项目依赖的其他 Catkin 项目 DEPENDS：此项目依赖的非 Catkin CMake 项目 CFG_EXTRAS：其他配置选项 详细参数参见文档 指定构建目标构建目标通常有多种形式，但是通常它们代表以下两种可能性之一： 可执行程序 库文件 目标命名需要注意的是，Catkin 中构建目标名称必须唯一，而与构建、安装到的文件夹无关，这也是 CMake 的要求，但是，构建目标名称的唯一性仅仅只是在 CMake 内部才是必须的。我们可以使用set_target_properties()函数将目标重命名为其他目标： 12345set_target_properties( rviz_image_view PROPERTIES OUTPUT_NAME image_view PREFIX &quot;&quot;) 在构建过程中，将目标rviz_image_view的名称更改为image_view 自定义输入目录通常将可执行程序和库文件的默认输出目录设置为合理的值，但在某些情况下必须对其进行自定义。例如，包含 Python 绑定的库必须放置在其他文件夹中才能在 Python 中导入 12345set_target_properties( python_module_library PROPERTIES LIBRARY_OUTPUT_DIRECTORY $&#123;CATKIN_DEVEL_PREFIX&#125;/$&#123;CATKIN_PACKAGE_PYTHON_DESTINATION&#125;) 包含路径和库路径在指定目标之前，你需要指定在哪里可以找到所需的资源，特别是头文件和库文件 包含路径：在哪里找到需要的头文件（在 C/C++ 中最常见） 1include_directories(&lt;dir1&gt; &lt;dir2&gt; ... &lt;dirN&gt;) 链接路径：在哪里可以找到库文件 1link_directories(&lt;dir1&gt; &lt;dir2&gt; ... &lt;dirN&gt;) include_directories()include_directories的参数因为 find_package 调动生成的*_INCLUDE_DIRS变量以及需要包含的任何其他目录。如果你需要使用 Catkin 和 Boost，则include_directories()调用应如下所示： 12345include_directories( include $&#123;Boost_INCLUDE_DIRS&#125; $&#123;catkin_INCLUDE_DIRS&#125;) link_directories()（不建议使用）link_directories() 函数可用于添加其他库的路径，但是不建议这么做。当所有 Catkin 和 CMake 的包被 find_package 时，会自动添加其链接信息，只需要使用target_link_libraries()链接即可。 可执行程序要指定必须构建的可执行程序，我们必须使用add_executable()函数。 1add_executable(main src/main.cc) 这将构建一个名为 main 的可执行程序，该可执行程序由 1 个源文件构建：src/main.cc 库文件使用add_library()函数来构建库文件。默认情况下，Catkin 构建共享库。 1234add_library( $&#123;PROJECT_NAME&#125; $&#123;$&#123;PROJECT_NAME&#125;_SRCS&#125;) target_link_libraries使用target_link_libraries()函数来指定可执行程序需要链接到的库文件。通常add_executable()调用之后完成此操作。如果找不到 ros，请添加$&#123;catkin_LIBRARIES&#125; 1target_link_libraries(&lt;executableTargetName&gt; &lt;lib1&gt; &lt;lib2&gt; ... &lt;libN&gt;) 注意：在大多数情况下都不需要使用 link_directories()，因为该信息是通过 find_package() 自动获取的 消息、服务和动作ROS 中的消息(.msg)，服务(.srv)和动作(.action)文件需要特殊的预处理器构建步骤，然后才能由 ROS 包构建和使用。这些宏的目的是生成特定编程语言的文件，以便人们可以选择其他编程语言来利用消息、服务和操作。构建系统将使用所有可用的生成器(gencpp, genpy, genlisp等)生成绑定。 Catkin 提供了三个宏来分别处理消息、服务和动作： add_message_files add_service_files add_action_files 然后，必须在使用完这些宏之后调用该宏以生成特定的文件： 1generate_messages() 重要的前提条件和约束 以下宏必须在 catkin_package()宏之前出现，以便正常工作 1234567find_package(catkin REQUIRED COMPONENTS ...)add_message_files(...)add_service_files(...)add_action_files(...)generate_messages(...)catkin_package(...)... 你的 catkin_package()必须对message_runtime具有CATKIN_DEPENDS依赖性 12345catkin_package( ... CATKIN_DEPENDS message_runtime ... ...) ros 你必须将message_generation添加到 find_package()中，无论是单独使用还是作为 Caktin 组件使用。 1234find_package( catkin REQUIRED COMPONENTS message_generation) 你的 package.xml文件中必须包含构建时依赖message_generation和运行时依赖message_runtime，如果依赖关系是其他包中传递过来的，则没有必要。 12&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 如果你有一个目标（甚至是过渡性的）依赖于需要构建消息、服务、操作的其他目标，则需要添加对目标的catkin_EXPORTED_TARGETS的显式依赖关系，以便以正确的顺序构建它们。这种情况几乎总是适用的，除非你的程序包确实不适用 ROS 的任何部分，这种依赖性不能自动传播。（some_target是有add_executable()设置的目标名称）： 1234add_dependencies( some_target $&#123;catkin_EXPORTED_TARGETS&#125;) 如果你具有用于构建消息和服务的程序包，以及适用这些消息和服务的可执行文件，则需要在自动生成消息目标上创建显示依赖项，以便用正确的顺序构建它们。（some_target是有add_executable()设置的目标名称）： 1234add_dependencies( some_target $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125;) 如果你的包满足上述两种情况，则你需要添加两个显式依赖： 12345add_dependencies( some_target $&#123;$&#123;PROJECT_NAME&#125;_EXPORTED_TARGETS&#125; $&#123;catkin_EXPORTED_TARGETS&#125;) 启用 Python 模块支持如果你的 ros 包提供了一些 Python 模块，则应创建 setup.py 文件并调用 1catkin_python_setup() 注意：必须在调用generate_messages()和catkin_package()之前调用 单元测试Catkin有一个特定的宏，用于处理基于 gtest 的单元测试，称为 catkin_add_target() 123if(CATKIN_ENABLE_TESTING) catkin_add_gtest(myUnitTest test/utest.cpp)endif()","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"CMakeLists","slug":"CMakeLists","permalink":"https://askeynil.github.io/tags/CMakeLists/"}]},{"title":"package.xml 详解","slug":"package.xml 详解","date":"2019-10-12T12:30:00.000Z","updated":"2020-11-04T10:55:07.308Z","comments":true,"path":"2019/b979b152.html","link":"","permalink":"https://askeynil.github.io/2019/b979b152.html","excerpt":"修改自 ros 官方 wiki http://wiki.ros.org/catkin/package.xml package.xml文件定义了包的属性，包括软件名称，版本号，作者，维护者，以及依赖关系。 基本结构每个package.xml文件都以&lt;package&gt;标记作为根标记 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package format=&quot;2&quot;&gt;&lt;/package&gt; 必备标签 No 标签 描述 1 &lt;name&gt; 包名 2 &lt;version&gt; 版本号（必须为 3 个点分隔的整数） 3 &lt;description&gt; 包内容的描述 4 &lt;maintainer&gt; 负责维护包裹的人员名称 5 &lt;license&gt; 许可，例如 GPL，BSD，ASL","text":"修改自 ros 官方 wiki http://wiki.ros.org/catkin/package.xml package.xml文件定义了包的属性，包括软件名称，版本号，作者，维护者，以及依赖关系。 基本结构每个package.xml文件都以&lt;package&gt;标记作为根标记 1234&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package format=&quot;2&quot;&gt;&lt;/package&gt; 必备标签 No 标签 描述 1 &lt;name&gt; 包名 2 &lt;version&gt; 版本号（必须为 3 个点分隔的整数） 3 &lt;description&gt; 包内容的描述 4 &lt;maintainer&gt; 负责维护包裹的人员名称 5 &lt;license&gt; 许可，例如 GPL，BSD，ASL 依赖关系 名称 标签 描述 构建依赖关系 &lt;build_depend&gt; 指定构建此软件包所需要的软件包 导出依赖关系 &lt;build_export_depend&gt; 指定针对该软件包构建库所需的软件包 执行依赖关系 &lt;exec_depend&gt; 指定运行该软件包中代码所需的软件包 测试依赖 &lt;test_depend&gt; 指定单元测试的其他依赖项 构建依赖工具 &lt;buildtool_depend&gt; 指定此软件包自行构建所需的构建系统工具，通常只需要 catkin。 文档工具依赖 &lt;doc_depend&gt; 指定此软件包生成文档所需的文档工具 特殊标签：&lt;depend&gt; 该标签相当于构建，导出，执行依赖关系。 原包（Metapackages）将多个软件包分组为一个软件软件包，通过 metapackages 完成，标签如下： 123&lt;export&gt; &lt;metapackage /&gt;&lt;/export&gt; 原包的 CMakeLists.txt 文件中必须包括 1234cmake_minimum_required(VERSION 2.8.3)project(&lt;PACKAGE_NAME&gt;)find_package(catkin REQUIRED)catkin_metapackage() 附加标签 &lt;url&gt; 有关包信息的 url &lt;author&gt; 包作者信息","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"}]},{"title":"ROS 工作空间和包","slug":"ROS 工作空间和包","date":"2019-10-12T12:00:00.000Z","updated":"2020-11-04T10:55:07.305Z","comments":true,"path":"2019/ros-ws-pkg.html","link":"","permalink":"https://askeynil.github.io/2019/ros-ws-pkg.html","excerpt":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 工作空间（workspace）1. 创建工作空间1mkdir -p cakin_ws/src cakin_ws为工作空间名。src为固定目录，不可更改。 2. 编译工作空间12cd cakin_wscatkin_make 来到之前创建好的工作空间目录下，使用catkin_make命令，将编译工作空间。 此时，我们的工作空间就创建完毕","text":"环境说明 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） Python版本：Python 2.7.12 CMake 版本：3.5.1 工作空间（workspace）1. 创建工作空间1mkdir -p cakin_ws/src cakin_ws为工作空间名。src为固定目录，不可更改。 2. 编译工作空间12cd cakin_wscatkin_make 来到之前创建好的工作空间目录下，使用catkin_make命令，将编译工作空间。 此时，我们的工作空间就创建完毕 3. 初始化工作空间遇到的坑conda 环境问题如果之前安装好，并且初始化了 conda 环境，可能会出现该问题，在错误信息中心会出现一些与 python 有关，带有 conda 的路径的一些信息。 原因分析 conda默认激活，python 路径为 conda 中的 python ros 的库都默认安装在了系统的 python2 中，导致catkin_make的时候，找不到 ros 需要的库 解决办法 完全退出 conda 环境 测试是否退出，使用命令 which python，打印的是不带 conda的路径，一般为/usr/bin/python 删除工作空间目录下的出 src 之外的所有文件，因为之前生成的会带有 Python 路径缓存。 1rm -rf `ls | grep -v src` 再一次 catkin_make即可 包（Package） 以下内容默认你已经创建了一个名为catkin_ws的工作空间，且编译成功。 创建一个包1234# 1. 进入 src 目录cd catkin_ws/src# 2. 创建名为 hello_ros 的包catkin_create_pkg hello_ros rospy roscpp std_msgs catkin_create_pkg就是创建包的命令了，其语法为 1catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] ... [dependn] 创建完成后，在 src目录下会生成hello_ros文件夹，该文件夹中包含两个文件package.xml和CMakeLists.txt，两个文件夹src和include/hello_ros package.xml包的一些描述信息 CMakeLists.txt cmake 配置文件 src 存放 C++源代码的文件夹 include/hello_ros存放 C++头文件的文件夹 编译一个包12# 在catkin工作空间下catkin_make catkin_make 以后会做更详细的介绍，此处我们使用catkin_make编译整个工作空间即可。 包的依赖关系一级依赖一级依赖就是直接依赖，在创建的时候，跟在包名之后的依赖都是该包的一级依赖，可以通过 rospack depends1 &lt;package_name&gt; 来查看一级依赖 间接依赖间接依赖就是，包的依赖包，还依赖着别的包，该包就是间接依赖。 查看所有依赖的命令rospack depends &lt;package_name&gt;","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"}]},{"title":"ROS 安装","slug":"ROS 安装","date":"2019-10-11T12:00:00.000Z","updated":"2020-11-04T10:55:07.304Z","comments":true,"path":"2019/ROS-Install.html","link":"","permalink":"https://askeynil.github.io/2019/ROS-Install.html","excerpt":"安装日期：2019-10-10 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） ROS源：Tsinghua University Python版本：Python 2.7.12 CMake 版本：3.5.1 一键安装脚本1curl https://gitee.com/askeynil/AskConfiguration/raw/master/ros.sh | bash 一些常用的 Ubuntu 自动化脚本： 码云 GitHub","text":"安装日期：2019-10-10 ROS版本：ROS Kinetic Kame Ubuntu版本：Ubuntu 16.04.6 LTS，（lsb_release -a） ROS源：Tsinghua University Python版本：Python 2.7.12 CMake 版本：3.5.1 一键安装脚本1curl https://gitee.com/askeynil/AskConfiguration/raw/master/ros.sh | bash 一些常用的 Ubuntu 自动化脚本： 码云 GitHub 手动安装方式 来源：ros 安装官方教程 更新 Ubuntu 为 Tsinghua 源 来源： Tsinghua 源 备份原有源文件 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 将 sources.list 备份一份为sources.list.bak 将以下文件覆盖 sources.list 里面的内容 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 更新源 1sudo apt update 添加 ros 源 添加 Tsinghua 的 ROS 源 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 设置秘钥 1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 更新源 1sudo apt update 安装 ros1sudo apt install ros-kinetic-desktop-full 初始化 rosdep12sudo rosdep initrosdep update 添加环境配置如果使用 bash，则 12echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 如果使用 zsh，则 12echo &quot;source /opt/ros/kinetic/setup.zsh&quot; &gt;&gt; ~/.zshrcsource ~/.zshrc 构建工厂依赖1sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential","categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"}],"tags":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"Shell","slug":"Shell","permalink":"https://askeynil.github.io/tags/Shell/"}]},{"title":"Matplotlib 常用整理","slug":"Matplotlib 常用整理","date":"2019-10-10T12:30:00.000Z","updated":"2020-11-04T10:55:07.300Z","comments":true,"path":"2019/matplotlib-common-method.html","link":"","permalink":"https://askeynil.github.io/2019/matplotlib-common-method.html","excerpt":"导入Matplotlib约定俗成的以 plt 为 Matplotlib 简称的导入方式 1import matplotlib.pyplot as plt 魔法配置，让表格显示在 jupyter 里面 1%matplotlib notebook 中文字体支持配置第一种方法 打印所有系统字体 12for i in sorted([f.name for f in mpl.font_manager.fontManager.ttflist]): print(i) 找到一个可以显示中文的字体 123# 比如我使用的 Songti SC# 将其设置为当前字体plt.rcParams[&#x27;font.family&#x27;]=[&#x27;Songti SC&#x27;]","text":"导入Matplotlib约定俗成的以 plt 为 Matplotlib 简称的导入方式 1import matplotlib.pyplot as plt 魔法配置，让表格显示在 jupyter 里面 1%matplotlib notebook 中文字体支持配置第一种方法 打印所有系统字体 12for i in sorted([f.name for f in mpl.font_manager.fontManager.ttflist]): print(i) 找到一个可以显示中文的字体 123# 比如我使用的 Songti SC# 将其设置为当前字体plt.rcParams[&#x27;font.family&#x27;]=[&#x27;Songti SC&#x27;] 第二种方法 找到自定义字体文件夹 1font_dirs = [&#x27;/Users/askeynil/Desktop/学习/numpy/fonts&#x27;] 将自定义字体文件夹导入到 Matplotlib 的字体库中 12345import matplotlib.font_manager as font_managerfont_dirs = [&#x27;/Users/askeynil/Desktop/学习/numpy/fonts&#x27;]font_files = font_manager.findSystemFonts(fontpaths=font_dirs)font_list = font_manager.createFontList(font_files)font_manager.fontManager.ttflist.extend(font_list) 然后使用方式一找到导入的字体，然后设置为 family 即可。 绘制折线图 创建一个图形实例 1fig = plt.figure() 获取 y 值，x 值默认从 0 开始，依次累加 1 1plt.plot([2, 3, 1, 4]) 设置 x，y 轴标签 12plt.xlabel(&#x27;x&#x27;) #x轴标签plt.ylabel(&#x27;y&#x27;) #y轴标签 绘制图形 1plt.show() 指定绘制图形的大小1fig = plt.figure(figsize=(5, 4), dpi=80) 参数解释： figsize：图形尺寸，英寸为单位 dpi：每英寸的点数 绘制三角函数12345678910111213141516# 1. 导入 numpyimport numpy as np# 2. 获取 x 轴的值x = np.linspace(-np.pi, np.pi, 100) # -pi 到 pi 中 100 个点# 3. 获取 cos 函数的 y 值c = np.cos(x)# 4. 获取 sin 函数的 y 值s = np.sin(x)# 5. 获取绘图实例fig = plt.figure()# 6. 绘制 cos 的图形plt.plot(x, c)# 7. 绘制 sin 的图形plt.plot(x, s)# 8. 显示图形fig.show() 指定线宽和颜色1234fig = plt.figure()plt.plot(x, c, color=&#x27;red&#x27;, linewidth=2, linestyle=&#x27;--&#x27;)plt.plot(x, s, color=&#x27;blue&#x27;, linewidth=3, linestyle=&#x27;-&#x27;)fig.show() 参数解释： color：线的颜色，可以是 RGB16 进制的数值，也可以是一些默认的预定义颜色字符串 linewidth：线宽 linestyle：线的形状 ‘-‘ 或 ‘solid’：实线 ‘–’ 或 ‘dashed’：短划线 ‘-.’ 或 ‘dashdot’：点虚线 ‘:’ 或 ‘dotted’：虚线 指定 x 和 y 轴的范围和标签的内容12345678910fig = plt.figure()plt.plot(x, c, color=&#x27;red&#x27;)plt.plot(x, s, color=&#x27;blue&#x27;)plt.xlim(-4, 4) # 指定 x 轴的范围plt.ylim(-1.1, 1.1) # 指定 y 轴的范围# 设置 x 轴的标签内容plt.xticks(np.linspace(-4, 4, 9, endpoint=True))# 设置 y 轴的标签内容plt.yticks(np.linspace(-1, 1, 5, endpoint=True))fig.show() 内联 LaTeX 表达式1234567891011fig = plt.figure()plt.plot(x, c, color=&#x27;red&#x27;)plt.plot(x, s, color=&#x27;blue&#x27;)plt.xlim(-4, 4) # 指定 x 轴的范围plt.ylim(-1.1, 1.1) # 指定 y 轴的范围# 设置 x 轴的标签内容plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\frac&#123;\\pi&#125;&#123;2&#125;$&#x27;, r&#x27;$0$&#x27;,r&#x27;$\\frac&#123;\\pi&#125;&#123;2&#125;$&#x27;, r&#x27;$\\pi$&#x27;])# 字符串前面加 r 表示使用原始字符串，不转义。# 设置 y 轴的标签内容plt.yticks(np.linspace(-1, 1, 5, endpoint=True))fig.show() 修改坐标轴的位置123456789101112131415161718192021fig = plt.figure()plt.plot(x, c, color=&#x27;red&#x27;)plt.plot(x, s, color=&#x27;blue&#x27;)plt.xlim(-4, 4) # 指定 x 轴的范围plt.ylim(-1.1, 1.1) # 指定 y 轴的范围# 设置 x 轴的标签内容plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi], [r&#x27;$-\\pi$&#x27;, r&#x27;$-\\frac&#123;\\pi&#125;&#123;2&#125;$&#x27;, r&#x27;$0$&#x27;,r&#x27;$\\frac&#123;\\pi&#125;&#123;2&#125;$&#x27;, r&#x27;$\\pi$&#x27;])# 字符串前面加 r 表示使用原始字符串，不转义。# 设置 y 轴的标签内容plt.yticks(np.linspace(-1, 1, 5, endpoint=True))# 获取当前的坐标轴 gca == get current axesaxes = plt.gca()# 设置右坐标轴颜色为 none 即隐藏右坐标轴axes.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)# 设置上坐标轴颜色为 none 即隐藏上坐标轴axes.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 将左坐标轴移动到原点axes.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 将下坐标轴移动到原点axes.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))fig.show() 添加函数描述12345fig = plt.figure()plt.plot(x, c, color=&#x27;red&#x27;, label=&#x27;cos&#x27;)plt.plot(x, s, color=&#x27;blue&#x27;, label=&#x27;sin&#x27;)plt.legend(loc=&#x27;upper left&#x27;) # Add the legendfig.show() 参数解释： label：函数的描述 plt.legend： loc：位置 ‘best’：最好的 ‘upper right’：右上 ‘upper left’：左上 ‘lower left’：左下 ‘lower right’：右下 ‘right’：右 ‘center left’：中左 ‘center right’：中右 ‘lower center’：下中 ‘upper center’：上中 ‘center’：中心 添加关键点标注123456789fig = plt.figure()plt.plot([2, 3, 1, 4]) plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.annotate(&#x27;转折点&#x27;, xy=(1, 3), xytext=(+10, +30), textcoords=&#x27;offset points&#x27;, fontsize=12, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;))fig.show() plt.annotate 参数解释： s：显示的文本 xy：标注点 xytext：放置文本的位置，默认为 xy textcoords：文本点的描述 fontsize：字体大小 arrowprops：箭头参数，dict 绘制多图 准备表格数据 123X = np.linspace(-np.pi, np.pi, 15)C = np.cos(X)S = np.sin(X) 绘制两个表格 123456fig = plt.figure()plt.subplot(2, 1, 1)plt.plot(X, C)plt.subplot(2, 1, 2)plt.plot(X, S)plt.show() 设置网格 12345678fig = plt.figure(figsize=(5, 4), dpi=80)plt.subplot(1, 2, 1)plt.plot(X, C)plt.grid(False)plt.subplot(1, 2, 2)plt.plot(X, S)plt.grid(True)plt.show() 参数解释： subplot(nrows, ncols, index, **kwargs) nrows：行数 ncols：列数 index：索引 kwargs：可选参数 subplot(pos, **kwargs) pos：100 &lt;= pos &lt;= 999 第一个数字代表行 第二个数字代表列 第三个数字代表索引 subplot(ax) ax：axes，之前 subplot 返回的值，在同一图内，再次绘制。 grid() 表格的配置信息 格子布局123456789101112131415161718192021# 导入布局头文件import matplotlib.gridspec as gridspecfig = plt.figure()# 创建布局管理器gs = gridspec.GridSpec(3, 3)# 绘制在 第 0 行所有列ax1 = plt.subplot(gs[0, :])plt.plot(X, C)# 绘制在第 1 行前两列 ax2 = plt.subplot(gs[1, :-1])plt.plot(X, S)# 绘制在最后一行，第 0 列ax3 = plt.subplot(gs[-1, 0])plt.plot(X, -C)# 绘制在最后一行，第 1 列ax4 = plt.subplot(gs[-1, -2])plt.plot(X, -S)# 绘制在第 1，2 行，最后一列ax5 = plt.subplot(gs[1:, -1])plt.plot(X, (C+S)/2)plt.show()","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://askeynil.github.io/tags/Matplotlib/"}]},{"title":"SymPy 常用整理","slug":"sympy 库使用","date":"2019-10-09T06:30:00.000Z","updated":"2020-11-04T10:55:07.308Z","comments":true,"path":"2019/ee3e502e.html","link":"","permalink":"https://askeynil.github.io/2019/ee3e502e.html","excerpt":"SymPy是一个符号计算的Python库。它的目标是成为一个全功能的计算机代数系统，同时保持代码简洁、易于理解和扩展。它完全由Python写成，不依赖于外部库。 以下使用导入并开启漂亮的打印 import sympy sympy.init_printing(pretty_print=True) 有理数 Rationals1sympy.Rational(1, 3) out： $\\frac{1}{3}$ 特殊的无理数1sympy.pi, sympy.E, sympy.oo out：$\\displaystyle \\left( \\pi, \\ e, \\ \\infty\\right)$","text":"SymPy是一个符号计算的Python库。它的目标是成为一个全功能的计算机代数系统，同时保持代码简洁、易于理解和扩展。它完全由Python写成，不依赖于外部库。 以下使用导入并开启漂亮的打印 import sympy sympy.init_printing(pretty_print=True) 有理数 Rationals1sympy.Rational(1, 3) out： $\\frac{1}{3}$ 特殊的无理数1sympy.pi, sympy.E, sympy.oo out：$\\displaystyle \\left( \\pi, \\ e, \\ \\infty\\right)$ 代数运算声明一个代数符号12x = sympy.Symbol(&#x27;x&#x27;) # 注意，声明一个代数的时候 S 为大写x out: $𝑥$ 声明多个代数符号12x, y = sympy.symbols(&#x27;x y&#x27;)x, y out: $\\displaystyle \\left( x, \\ y\\right)$ 声明带下标的代数符号12x1, x2 = sympy.symbols(&#x27;x1 x2&#x27;)x1, x2 out：$\\displaystyle \\left( x_{1}, \\ x_{2}\\right)$ 简单的代数运算1x ** 2 + 2 * x + 1 out：$\\displaystyle x^{2} + 2 x + 1$ 1x1 + x2 ** 2 - x2 + x1 /2 out：$\\displaystyle \\frac{3 x_{1}}{2} + x_{2}^{2} - x_{2}$ 展开和分解1x, y = sympy.symbols(&#x27;x y&#x27;) 展开多项式1sympy.expand((x + y) ** 2) out：$\\displaystyle x^{2} + 2 x y + y^{2}$ 展开三角函数1sympy.expand(sympy.sin(x + y), trig=True) out：$\\displaystyle \\sin{\\left(x \\right)} \\cos{\\left(y \\right)} + \\sin{\\left(y \\right)} \\cos{\\left(x \\right)}$ 化简1sympy.simplify((x + x*y) / x) out：$\\displaystyle y + 1$ 求和运算Sum$$\\frac{1}{1^2+2\\cdot 1} + \\frac{1}{2^2+2\\cdot 2} + \\cdots + \\frac{1}{10^2+2\\cdot 10}$$ 12expr = sympy.Sum(1/(x**2 + 2*x), (x, 1, 10))expr.doit() expr：$\\displaystyle \\sum_{x=1}^{10} \\frac{1}{x^{2} + 2 x}$ out： $\\displaystyle \\frac{175}{264}$ 乘积运算 Product$$\\frac{1}{1^2+2\\cdot 1} \\times \\frac{1}{2^2+2\\cdot 2} \\times \\cdots \\times \\frac{1}{10^2+2\\cdot 10}$$ 12expr &#x3D; sympy.Product(1&#x2F;(x**2 + 2*x), (x, 1, 10))expr.doit() expr：$\\displaystyle \\prod_{x=1}^{10} \\frac{1}{x^{2} + 2 x}$ out：$\\displaystyle \\frac{1}{869100503040000}$ 极限计算$$\\lim_{x \\rightarrow 0}\\frac{\\sin x}{x}$$ 1sympy.limit(sympy.sin(x)/x, x, 0) # 1 $$\\lim_{x \\rightarrow \\infty} x$$ 1sympy.limit(x, x, sympy.oo) # ∞ $$\\lim_{x \\rightarrow \\infty} \\frac{1}{x}$$ 1sympy.limit(1/x, x, sympy.oo) # ∞ 左极限和右极限$$\\lim_{x \\rightarrow 0^{-}} \\frac{1}{x}，\\lim_{x \\rightarrow 0^{+}} \\frac{1}{x}$$ 12sympy.limit(1/x, x, 0, dir=&#x27;+&#x27;) # ∞sympy.limit(1/x, x, 0, dir=&#x27;-&#x27;) # −∞ 导数1sympy.diff(x**2, x) out：$\\displaystyle 2 x$ 1sympy.diff(sympy.sin(2*x), x) out：$\\displaystyle 2 \\cos{\\left(2 x \\right)}$ 1sympy.diff(sympy.sin(x**2+2*x), x) out：$\\displaystyle \\left(2 x + 2\\right) \\cos{\\left(x^{2} + 2 x \\right)}$ 多阶导数1sympy.diff(x**2, x, 2) # 2(x**2对 x 求二阶导数) 积分不定积分$$\\int_{ -\\infty }^{ \\infty } 6x^5$$ 1sympy.integrate(6 * x**5, x) out：$x^6$ 定积分$$\\int_{0}^{\\frac{\\pi}{2}} \\sin x$$ 1sympy.integrate(sympy.sin(x), (x, 0, sympy.pi/2)) out：1 解方程解一元方程1sympy.solve(x**2-3*x+2, x) out：$\\displaystyle \\left[ 1, \\ 2\\right]$ 解二元方程1sympy.solve([x+5*y-2, -3*x+6*y-15], [x, y]) out：$\\displaystyle \\left{ x : -3, \\ y : 1\\right}$ 代数运算12expr = x**2 + 2*x + 1expr out：$\\displaystyle x^{2} + 2 x + 1$ 令 x = 2 1expr.subs(x, 2) out：9 令 x = y + 1 1expr.subs(x, y+1) out：$\\displaystyle 2 y + \\left(y + 1\\right)^{2} + 3$ 阶乘123n = sympy.Symbol(&#x27;n&#x27;)a = sympy.factorial(n)a.subs(n, 5) out：120 多元函数的代数12expr = x ** 3 + 4 * x * y - zexpr out：$\\displaystyle x^{3} + 4 x y - z$ 1expr.subs([(x, 2), (y, 4), (z, 0)]) out：40 字符串转 SymPy 表达式123str_expr = &quot;x**2 + 3*x - 1/2&quot;expr = sympy.sympify(str_expr)expr out：$\\displaystyle x^{2} + 3 x - \\frac{1}{2}$ 概率论问题导入框架import sympy.stats 骰子问题 创建一个有 6 个面的骰子 1x = sympy.stats.Die(&#x27;x&#x27;, 6) 查看每个面出现的概率 1sympy.stats.density(x).dict out：$\\displaystyle \\left{ 1 : \\frac{1}{6}, \\ 2 : \\frac{1}{6}, \\ 3 : \\frac{1}{6}, \\ 4 : \\frac{1}{6}, \\ 5 : \\frac{1}{6}, \\ 6 : \\frac{1}{6}\\right}$ 随机丢一个骰子 1sympy.stats.sample(x) # out: 5 丢出骰子大于 3 的概率 1sympy.stats.P(x &gt; 3) 硬币问题 创建一个硬币 1c = sympy.stats.Coin(&#x27;c&#x27;) 查看每个面出现的概率 1sympy.stats.density(c).dict out：$\\displaystyle \\left{ H : \\frac{1}{2}, \\ T : \\frac{1}{2}\\right}$ 与创建两个面的骰子类似 正态分布 创建一个标准正态分布 1z = sympy.stats.Normal(&#x27;z&#x27;, 0, 1) 标准正态分布中数据大于 1 的概率 12sympy.stats.P(z &gt; 1).evalf()# out: 0.158655253931457","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"SymPy","slug":"SymPy","permalink":"https://askeynil.github.io/tags/SymPy/"}]},{"title":"NumPy 常用整理","slug":"numpy 常用整理","date":"2019-10-09T03:30:00.000Z","updated":"2020-11-04T10:55:07.308Z","comments":true,"path":"2019/a62eab8c.html","link":"","permalink":"https://askeynil.github.io/2019/a62eab8c.html","excerpt":"导入 numpy约定俗成的以 np为numpy简称的导入方式 import numpy as np numpy.array 创建一个数组 参数: object：类数组 dtype：数据类型（data-type），默认为 None copy：是否拷贝，默认为 True order：内存布局（’K’，’A’，’C’，’F’），默认为 ‘K’ subok：传递子类还是基类，默认为 False，即传递基类 ndmin：最小维度，默认为 0 返回值： out：ndarray","text":"导入 numpy约定俗成的以 np为numpy简称的导入方式 import numpy as np numpy.array 创建一个数组 参数: object：类数组 dtype：数据类型（data-type），默认为 None copy：是否拷贝，默认为 True order：内存布局（’K’，’A’，’C’，’F’），默认为 ‘K’ subok：传递子类还是基类，默认为 False，即传递基类 ndmin：最小维度，默认为 0 返回值： out：ndarray 一些简单的🌰 创建一个简单一维数组 12np.array([1, 2, 3])# array([1, 2, 3]) 创建一个简单二维数组 1234np.array([[1, 2], [3, 4]])# array([[1, 2],# [3, 4]]) 创建一个最小维度为 2 的数组 12np.array([1,2,3], ndmin=2)# array([[1, 2, 3]]) 使用矩阵创建数组 123np.array(np.mat(&#x27;1 2; 3 4&#x27;))# array([[1, 2],# [3, 4]]) 使用 array 返回子类 123np.array(np.mat(&#x27;1 2; 3 4&#x27;), subok=True)# matrix([[1, 2],# [3, 4]]) ndarray 的一些常用属性 属性 解释 ndim 秩，即维度的数量 shape 数组的形状，即数组的维度 size 数组元素的总个数 dtype 其内元素类型 itemsize 每个元素的大小 T 转置 flat 数组的一维迭代器 ndarray 的一些常用方法 方法 解释 astype() 将类型转化为指定类型 ravel() 将数组展开成一维数组 sum() 数组元素求和 all() 是不是都为 True any() 是不是存在 True argmax() 最大值的索引 max() 最大值 argmin() 最小值的索引 min() 最小值 argsort() 排序的索引 sort() 排序 dot() 矩阵相乘 fill() 填充数据 mean() 平均值 reshape() 更改形状 std() 标准差 var() 方差 nonzero() 获取非零元素的索引 put() 用给定的值替换数组的指定元素 transpose() 转置，等同于 T flatten() 返回一份拷贝数组 ptp() 最大值与最小值的差 average() 加权平均值 数组的运算12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 数组的四则运算# 1. shape 相同，对应元素的四则运算# 2. shape 不同，使用广播机制，然后按 shape 相同的规则计算# 加法np.eye(2) + np.eye(2)# 减法np.eye(2) - np.eye(2)# 乘法np.eye(2) * np.eye(2)# 除法np.eye(2) / np.eye(2)# 矩阵相乘np.eye(2) @ np.eye(2)# 指数运算 2次方np.eye(2) ** 2 # 取余运算np.eye(2) % 10# 创建一个二维数组a = np.eye(2)# 和a.sum()# 平均数a.mean()# 加权平均值a.average()# 最大值a.max()# 最小值a.min()# 中位数np.median(a)# 最大值与最小值的差a.ptp()# 方差a.var()# 标准差a.std()# 三角函数# sinnp.sin(a)# cosnp.cos(a)# tannp.tan(a)# 向下取整np.floor(a)# 进一取整np.ceil(a) numpy.arange 返回给定间隔内均匀间隔的数组 参数 start：开始值，默认为 0 stop：结束值 step：步长，默认为 1 dtype：数据类型，默认为 None 返回值 out：ndarray 一些简单的🌰 创建 0-2 的数组 12np.arange(3)# array([0, 1, 2]) 创建一个 2-7 的数组 12np.arange(2, 7)# array([2, 3, 4, 5, 6]) numpy.linspace Return evenly spaced numbers over a specified interval. 返回指定间隔内的等间隔数字 参数 start：开始值 stop：结束值 num：数量，默认为 50 endpoint：是否包含stop 这个数字，默认为 True retstep：是否返回间隔数字之间的间隔，默认 False dtype：数据类型，默认为 None axis：按哪个轴获取。默认为 0 返回值： samples：ndarray step：步长，只有当 retstep 为True 时才有该值。 一些简单的🌰 创建一个 2.0 到 3.0 之间的 5 个等间距数字数组 12np.linspace(2.0, 3.0, num=5)# array([2. , 2.25, 2.5 , 2.75, 3. ]) 上面的例子中，创建不包含结束值的数组 12np.linspace(2.0, 3.0, num=5, endpoint=False)# array([2. , 2.2, 2.4, 2.6, 2.8]) 第一个例子，返回步长 12np.linspace(2.0, 3.0, num=5, retstep=True)# (array([2. , 2.25, 2.5 , 2.75, 3. ]), 0.25) numpy.ones, numpy.zeros, numpy.empty ones：按照形状创建一个元素全为 1 的数组 zeros：按照形状创建一个元素全为 0 的数组 empty：按照形状创建一个元素全部无意义的数组 参数： shape：形状 dtype：数据类型，默认为 None order：内存布局（’C’, ‘F’），默认为 C 返回值 out：ndarray 一些简单的🌰 创建一个形状为 2 的数组 123456np.ones(2)# array([1., 1.])np.zeros(2)# array([0., 0.])np.empty(2)# array([0., 0.]) 未初始化的值，无意义 创建一个形状为 (2, 2) 数组 123456789np.ones((2, 2))# array([[1., 1.],# [1., 1.]])np.zeros((2, 2))# array([[0., 0.],# [0., 0.]])np.empty((2, 2))# array([[0.25, 0.5 ],# [0.75, 1. ]]) 未初始化的值，无意义 numpy.eye（任意对角线为 1 的数组） Return a 2-D array with ones on the diagonal and zeros elsewhere. 返回一个二维数组，对角线为 1，其他都为 0 参数： N：行数 M：列数，默认等于行 k：对角线索引，默认为 0，即主对角线，正数往右上平移，负数往左下平移。 dtype：数据类型 order：内存布局 （’C’, ‘F’），默认为 C 返回值 I：ndarray of shape (N, M) 一些简单的🌰 创建一个 2 行 2 列的主对角线为 1 的数组 123np.eye(2)# array([[1., 0.],# [0., 1.]]) 创建一个3 行 3 列，第 k=1 条对角线为 1 的数组 1234np.eye(3, k=1)# array([[0., 1., 0.],# [0., 0., 1.],# [0., 0., 0.]]) numpy.identity（单位数组） 返回单位数组，即主对角线为 1 该方法等同于 numpy.eye(n, M=n, k=0) 参数： n：行列数 dtype：数据类型，默认为 None 返回值： out：ndarray 创建一个 2 行 2 列的主对角线为 1 的数组 123np.identity(2)# array([[1., 0.],# [0., 1.]]) 行向量与列向量numpy 中一维数组的行向量和列向量没有什么区别 123a = np.arange(3)a # array([0, 1, 2])a.T # array([0, 1, 2]) 二维的行列向量才有差别 123456a = np.array([[1, 2, 3]])a # array([[1, 2, 3]])a.T # array([[1],# [2],# [3]]) 一维行向量变成二维列向量 123456a = np.arange(3)a # array([0, 1, 2])a.reshape(-1, 1)# array([[0],# [1],# [2]]) 使用特殊方法创建行列向量 创建行向量 1np.r_[1,2,3,4] # array([1, 2, 3, 4]) 创建列向量 1234np.c_[[1,2,3]]# array([[1],# [2],# [3]]) 数组的切片和索引一维数组的切片和索引1a = np.arange(10) 问 答 问 答 索引1 a[1] 取[2, 5) a[2:5] 步长 2 a[::2] 倒序 a[::-1] 二维数组的切片和索引1a = np.arange(25).reshape(5, 5) 问 答 问 答 第一行 a[1] 第一列 a[…,1]或a[:,1] 取(1, 1)的元素 a[1, 1] 紫色区域 a[…:1] 红色区域 a[1, 2:4] 绿色区域 a[-2:,-2:] 黄色区域 a[::2, 2::2] 黄色区域 a[::2, [2, 4]] 问 答 问 答 红色区域 a[[0, 2, 4],[0, 2, 4]] 绿色区域 a[[1, 3 ,4], 3:] 黄色区域 a[2::3, [0, 2, 3]] 紫色区域 a[1,1:4] 还有掩码切割的方式 黄色区域 12mask = np.array([True, False, True, True, False])a[1::3, mask] 紫色区域 12mask = np.array([False, True, True, True, False])a[1, mask] 数组拆分1a = np.arange(9).reshape(3, 3) 按行拆分 12np.vsplit(a, 3)# [array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])] 按列拆分 12345678np.hsplit(a, 3)# [array([[0],# [3],# [6]]), array([[1],# [4],# [7]]), array([[2],# [5],# [8]])] 数组合并12a = np.arange(4).reshape(2, 2)b = np.arange(4).reshape(2, 2) 竖直合并 12345np.vstack([a,b])# array([[0, 1],# [2, 3],# [0, 1],# [2, 3]]) 水平合并 123np.hstack([a,b])# array([[0, 1, 0, 1],# [2, 3, 2, 3]]) numpy的广播机制以下内容来自菜鸟教程 广播的规则: 让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。 输出数组的形状是输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。 简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足： 数组拥有相同形状。 当前维度的值相等。 当前维度的值有一个是 1。 若条件不满足，抛出 “ValueError: frames are not aligned” 异常。","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"https://askeynil.github.io/tags/NumPy/"}]},{"title":"numpy.random","slug":"numpy.random","date":"2019-10-09T00:30:00.000Z","updated":"2020-11-04T10:55:07.308Z","comments":true,"path":"2019/6a1d78d1.html","link":"","permalink":"https://askeynil.github.io/2019/6a1d78d1.html","excerpt":"randint（随机整数） Return random integers from low (inclusive) to high (exclusive). 从区间 [low, high) 中返回随机的整数数组 参数 low：最小值 high：最大值，默认为 None size：个数，默认为None dtype：数据类型，默认为’l’ 返回值 out：整型或者整型数组 一些简单的🌰 0 到 50 中随机一个数 12np.random.randint(50)# 26 10 到 50 中随机一个数 12np.random.randint(10, 50)# 36 0 到 50 中随机 10 个数 12np.random.randint(50, size=10)# array([10, 25, 37, 34, 13, 15, 16, 12, 44, 4]) 10 到 50 中随机 10 个数 12np.random.randint(10, 50, 10)# array([40, 46, 27, 44, 30, 46, 15, 41, 18, 23])","text":"randint（随机整数） Return random integers from low (inclusive) to high (exclusive). 从区间 [low, high) 中返回随机的整数数组 参数 low：最小值 high：最大值，默认为 None size：个数，默认为None dtype：数据类型，默认为’l’ 返回值 out：整型或者整型数组 一些简单的🌰 0 到 50 中随机一个数 12np.random.randint(50)# 26 10 到 50 中随机一个数 12np.random.randint(10, 50)# 36 0 到 50 中随机 10 个数 12np.random.randint(50, size=10)# array([10, 25, 37, 34, 13, 15, 16, 12, 44, 4]) 10 到 50 中随机 10 个数 12np.random.randint(10, 50, 10)# array([40, 46, 27, 44, 30, 46, 15, 41, 18, 23]) random/random_sample（随机 0-1 的浮点数） Return random floats in the half-open interval [0.0, 1.0). 返回一个在 0-1 之间的随机的浮点数的数组 参数 size：大小，默认为 None 返回值 out：浮点数或浮点数数组 一些简单的🌰 随机返回一个浮点数 1np.random.random() # 0.939393746883071 随机返回有一个浮点数的数组 1np.random.random(1) # array([0.70345759]) 随机返回 10 个浮点数的数组 123np.random.random(10)# array([0.84469124, 0.16361142, 0.59353651, 0.80872106, 0.15086249,# 0.4595056 , 0.5550403 , 0.59146936, 0.07822706, 0.99842643]) rand（随机 0-1 给定形状的浮点数） Random values in a given shape. 按照给定的形状返回数据（值为[0, 1) ） 参数 d0, d1, …, dn：形状信息，默认为 None，即可以不传数据 返回值 out：ndarray 一些简单的🌰 不传数据 12np.random.rand()# 0.4506933261729883 返回一个 2 x 2的随机数组 123np.random.rand(2, 2)# array([[0.67949434, 0.73498025],# [0.21896692, 0.54682848]]) randn（标准正态分布中随机样本） Return a sample (or samples) from the “standard normal” distribution. 从标准正态分布返回一个或多个样本 参数： d0, d1, …, dn：形状信息 返回值： Z：浮点型或者浮点型数组 一些简单的🌰 不传数据 1np.random.randn() # 1.5567818373271456 返回 2 x 5 的标准正态分布样本 123np.random.randn(2, 5)# array([[ 1.15218971, -0.19590126, 0.10391749, -0.46857231, 0.58370011],# [-0.29639999, -0.73765977, -0.03441631, 0.26545265, 0.25255167]]) normal（正态分布中随机样本） Draw random samples from a normal (Gaussian) distribution. 从正态分布中抽取随机样本，默认返回标准正态分布 参数 loc：期望值，默认为 0 scale：标准差，默认为 1 size：大小，默认为 None 返回值 out：浮点型或者浮点型数组 一些简单的🌰 不传参数，默认为标准正态分布 12np.random.normal() # 0.39605193328763477 期望值为 1，标准差为 2 的正态分布 12np.random.normal(1, 2) # 0.9208239350120327 获取 10 个期望值为 5，标准差为 2 的正态分布的值 1234np.random.normal(5, 2, 10)# array([5.66208783, 3.63723912, 4.4776973 , 5.20380349, 6.0451376 ,# 4.53452163, 2.34042043, 4.43470636, 6.75530746, 1.95167798]) choice（从给定数据中随机样本） Generates a random sample from a given 1-D array 从给定的一维数组中，生成随机样本 参数： a：随机的参数 如果是 ndarray，则从中随机一个数字 如果是 int，则从 np.arange(a) 中随机一个数组 size：大小，默认为 None replace：是否要放回取样，默认为 True p：随机选取对应索引的概率 返回值： samples：single item or ndarray 一些简单的🌰 从 0-9 中随机选择一个元素 1np.random.choice(10) # 2 从 0-9 中不放回取样 10 个数据 12np.random.choice(10, 10, False)# array([8, 9, 5, 0, 1, 4, 3, 6, 7, 2]) 从0 - 1中取样 10 个数据，0 的取样概率为 0.8，1 的取样概率为 0.2 12np.random.choice(2, 10, p=[0.8, 0.2])# array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1]) uniform（均匀分布抽取） Draw samples from a uniform distribution. 从均匀分布中抽取样本 参数 low：下界，默认为 0 high：上界，默认为 1 size：大小，默认为 None 返回值 out：ndarray or scalar 一些简单的🌰 不传参数，默认 [0, 1) 的均匀分布 1np.random.uniform() # 0.237545651484531 获取[2, 10)中均匀分布的一个样本 1np.random.uniform(2, 10) # 3.751506848826293 数据打散permutation（不修改原数据） Randomly permute a sequence, or return a permuted range. 随机排序一个序列，返回排序的结果 参数 x：同 choice 中的 a 返回值 out：ndarray 12np.random.permutation(10)# array([7, 1, 0, 6, 9, 5, 3, 8, 4, 2]) shuffle（修改原数据） Modify a sequence in-place by shuffling its contents. 原地修改一个数组的顺序 参数 x 123a = np.arange(10)np.random.shuffle(a)a # array([4, 3, 9, 5, 6, 1, 8, 0, 2, 7]) 随机种子seed seed一旦定下来之后，如果是固定的 seed，则每次随机的结果都是一样的。 注意：seed 的有效次数仅为一次 123np.random.seed(2)np.random.randint(100)# 40","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"https://askeynil.github.io/tags/NumPy/"}]},{"title":"LeetCode 题解：746. 使用最小花费爬楼梯","slug":"LeetCode 题解：746. 使用最小花费爬楼梯","date":"2019-09-24T11:00:00.000Z","updated":"2020-11-04T10:55:07.300Z","comments":true,"path":"2019/leetcode-746.html","link":"","permalink":"https://askeynil.github.io/2019/leetcode-746.html","excerpt":"题目 点我查看详细原题 题目大意： 数组的每个值对应为一个阶梯数 每个阶梯数都对应一个体力花费数 每爬一个阶梯就要消耗相应的体力 可以选择一次爬一个或者一次爬两个（就是跳过一个阶梯，跳过的阶梯不算体力） 找到到达目的地的最低体力花费数 可以从 0 或 1 开始爬 示例 1: 1234输入: cost &#x3D; [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 1234输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。","text":"题目 点我查看详细原题 题目大意： 数组的每个值对应为一个阶梯数 每个阶梯数都对应一个体力花费数 每爬一个阶梯就要消耗相应的体力 可以选择一次爬一个或者一次爬两个（就是跳过一个阶梯，跳过的阶梯不算体力） 找到到达目的地的最低体力花费数 可以从 0 或 1 开始爬 示例 1: 1234输入: cost &#x3D; [10, 15, 20]输出: 15解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。 示例 2: 1234输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。 题目分析动态规划思想按结果分析，最终结果可以从倒数第一个到达和倒数第二个到达 假设只有两个元素 此时的结果就是 cost[0] 和 cost[1] 中最小的那个 假设只有三个元素分别为 1，2，3 我们可以一眼看出最小的结果即为 2。仔细观察就会发现，我们取了爬到 2 和 3 元素的最小值，因为爬到 2 元素消耗为2，爬到 3 元素消耗为 3。 为何爬到 3 元素消耗为 3 呢 因为我们选择了 1 元素为起始点，并且略过了 2 元素 爬到 3 元素的表达式怎么写? min(cost[0], cost[1]) + cost[3] 比较爬到 3 元素和 2 元素的消耗，不难得出最终登上楼梯的最小消耗为 2 根据动态规划思想写转移方程 dp[0] = cost[0] 、dp[1] = cost[1]、dp[2] = min(dp[0] + dp[1]) + cost[2] 将 3 个元素的转移方程推广到 n 个元素 dp[n] = min(dp[n-1] + dp[n-2]) + cost[n] 此时 n &gt; 2 图解如下仔细观察就会发现，我们取了跳到 2 和 3 元素的最小值，因为跳到 2 元素消耗为2，跳到 3 元素消耗为 3。 复杂度分析 时间复杂度：O(n) 空间复杂度：O(n) 因为借用了 dp 数组，所以空间复杂度为 O(n)，此题也可以将 dp 数组修改为 两个变量从而实现空间复杂度为 O(1)的情况。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://askeynil.github.io/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://askeynil.github.io/categories/Algorithm/LeetCode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://askeynil.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://askeynil.github.io/tags/Dynamic-Programming/"},{"name":"LeetCode Easy","slug":"LeetCode-Easy","permalink":"https://askeynil.github.io/tags/LeetCode-Easy/"}]},{"title":"MySql 整理","slug":"MySql 整理","date":"2019-09-23T01:00:00.000Z","updated":"2020-11-04T10:55:07.301Z","comments":true,"path":"2019/Basics-of-MySQL.html","link":"","permalink":"https://askeynil.github.io/2019/Basics-of-MySQL.html","excerpt":"SQL 的分类 SQL： Structrued Query Language 结构化的查询语言 DDL ：数据定义语言，定义数据库、表结构 create 创建 drop 删除 alter 修改 truncate 截断 DML： 数据库操纵语言，操作的对象是数据 insert 插入 update 更新 delete 删除 DCL ：数据库控制语言，控制的是权限 grant 授权 revoke 取消授权 DQL ：数据库查询语言，查询数据 select 查询","text":"SQL 的分类 SQL： Structrued Query Language 结构化的查询语言 DDL ：数据定义语言，定义数据库、表结构 create 创建 drop 删除 alter 修改 truncate 截断 DML： 数据库操纵语言，操作的对象是数据 insert 插入 update 更新 delete 删除 DCL ：数据库控制语言，控制的是权限 grant 授权 revoke 取消授权 DQL ：数据库查询语言，查询数据 select 查询 常用命令DDL（数据定义语言）创建数据库12# 用 xxx 为数据库名称创建一个数据库create database xxx; 删除数据库12# 删除名称为 xxx 的数据库drop database xxx; 修改数据库12345# 修改数据库编码# 修改 xxx 数据库的编码为 gbkalter database xxx character set gbk;# 一般很少修改数据库，最常用的为修改数据库编码，虽然这也非常少用到。 显示数据库12345# 显示所有数据库show databases;# 显示 xxx 数据库创建的语句和编码show create database xxx; 创建数据表12345678910111213&#x2F;* 语法：create table 表名（ 字段名 类型(长度) [约束]， 字段名 类型(长度) [约束]， ...）;*&#x2F;# 🌰create table aa ( id int primary key auto_increment, username varchar(20));# 创建表 aa，aa 中有两个字段分别是 int 类型的主键 id 和 varchar 类型的 username 删除数据表12345678&#x2F;*语法：drop table 表名*&#x2F;# 🌰drop table aa;# 删除表 aa 修改数据表12345678910111213141516171819202122232425&#x2F;*语法1. 在表中添加列alter table 表名 add 列名 类型(长度) [约束];2. 修改表中存在列的类型长度alter table 表名 modify 列名 类型(长度) [约束];3. 修改列名alter table 表名 change 旧列名 新列名 类型(长度) [约束];4. 删除列alter table 表名 drop 列名;5. 修改表名（比较少用）rename table 表名 to 新表名;*&#x2F;# 🌰# 1. 在 aa 表中添加一列名为 agealter table aa add age int;# 2. 将 aa 表中的 username 的长度修改为 30alter table aa modify username varchar(30);# 3. 修改 aa 表中 username 的名称为 nicknamealter table aa change username nickname varchar(30);# 4. 删除 aa 表中的 age 列alter table aa drop age;# 5. 修改 aa 的表名为 bbrename table aa to bb; 显示数据表12345678# 显示当前数据库中 所有的数据表show tables;# 显示 xxx 表中的具体结构 desc xxx;# 显示 xxx 表的建表结构show create table xxx; DML（数据库操纵语言）增加数据12345678910111213&#x2F;*语法：1. 添加一条记录，对具体的列进行赋值，若是字符或者日期类型需要加 &#39;&#39; 引号insert into 表名 (列 1, 列 2, 列 3) values(值 1, 值 2, 值 3);2. 添加一条记录，对表中所有的列进行赋值，按建表语句中的顺序insert into 表名 values(值 1, 值 2, 值 3)*&#x2F;# 🌰# 1. 将 username 为 &#39;zhangsan&#39; 数据添加到 aa 表中insert into aa (username) values(&#39;zhangsan&#39;);# 2. 将 null, lisi 添加到 aa 数据库中, 因为 id 是 primary key auto_increment 传递 null 给它，其会自增insert into aa values(null, &#39;lisi&#39;); 删除数据1234567891011&#x2F;*语法：delete from 表名 [where 条件]将满足条件的所有表删除，如果不加条件，即为所有都满足，删除所有表记录*&#x2F;# 🌰# 1. 将表中 username 为 lisi 的记录删除delete from aa where username&#x3D;&#39;lisi&#39;# 2. 逐一删除 aa 表中所有记录delete from aa; 修改数据1234567891011&#x2F;*语法：update 表名 set 字段名1&#x3D;值1，字段名2&#x3D;值2 [where 条件];将满足条件的数据中的 字段名1 改为 值1 ，字段名2 改为 值2*&#x2F;# 🌰# 1. 将 aa 数据库中 username 为 zhangsan 的记录的 age 改为 20update aa set age &#x3D; 20 where username &#x3D; &#39;zhangsan&#39;# 2. 不带 where, 表中所有记录的 age 都改为 20update aa set age &#x3D; 20; DCL（数据库控制语言）MySQL账户体系，根据账户所具有的权限的不同，MySQL 的账户可以分为以下几种 服务实例级账号：启动一个 mysqld，即为一个数据库的实例，如果某用户如 root，拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库，连同这些库中的表 数据库级别账号：对特定数据库进行增删改查的操作 数据表级别账号：对特定表执行增删改查的操作 字段级别的账号：对某些表的特定字段进行操作 存储程序级别的账号：对存储程序进行增删改查的操作 ！注意：进行账户操作时，需要使用 root 账户登录，这个账户拥有最高的实例权限。账户的操作主要包括创建账户、删除账户、修改密码、授权权限等。 1234# 常用的权限主要有create、 alter、 drop、 insert、 update、 delete、 select# 如果分配所有权限 可以使用all privileges 创建账户、授权1234567891011# 创建账户create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;# 授权grant 权限 on 数据库.表名 to &#39;用户名&#39;@&#39;主机名&#39;;# 🌰# 创建 &#39;zhangsan&#39;@&#39;localhost&#39; 账号create user &#39;zhangsan&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;# 将查询 demo 数据库中 user 表的权限授予 &#39;zhangsan&#39;@&#39;localhost&#39; 账号grant select on demo.user to &#39;zhangsan&#39;@&#39;localhost&#39;; 可以操控demo数据库的 user 表，方式为 demo.user 访问主机通常使用 % 表示此账户可以用任何 ip 的主机登录访问此数据库 访问主机可以设计为 localhost 或具体的 ip 表示只允许本机和特定的 ip 才可以访问 查看用户权限1show grants for &#39;zhangsan&#39;@&#39;localhost&#39;; 删除权限1234567revoke 权限名称 on 数据库.表名 from &#39;用户名&#39;@&#39;主机名&#39;;# 🌰# 删除 zhangsan 对 demo 数据中 user 表查询的权限revoke select on demo.user from &#39;zhangsan&#39;@&#39;localhost&#39;;# 刷新权限flush privileges 修改密码12345set password for &#39;用户名&#39;@&#39;主机名&#39; &#x3D; password(&#39;新密码&#39;);# 🌰# 将 &#39;zhangsan&#39;@&#39;localhost&#39; 用户密码设置为 123456set password for &#39;zhangsan&#39;@&#39;localhost&#39; &#x3D; password(&#39;123456&#39;); 删除账户1234567891011121314&#x2F;*语法 1：drop user &#39;用户名&#39;@&#39;主机名&#39;;语法 2：delete from user where user&#x3D;&#39;用户名&#39;;推荐使用语法 1 的方式删除用户，如果语法 1 删除不成功，再使用语法 2 的方式。*&#x2F;# 🌰# 方式 1drop user &#39;zhangsan&#39;@&#39;localhost&#39;;# 方式 2delete from user where user&#x3D;&#39;zhangsan&#39;; DQL（数据库查询语言）准备工作 为了后面的 🌰 方便，准备了一份数据 12345678910111213141516171819202122232425262728293031# 准备一张商品分类表(分类ID,分类名称,分类描述)create table category( cid int primary key auto_increment, cname varchar(10), cdesc varchar(50));# 准备一张商品表(商品编号,商品名称,商品价格,商品描述,商品分类编号)create table product( pid int primary key auto_increment, pname varchar(10), price double, pdesc varchar(50), cno int);# 数据的准备insert into category values(null,&#39;手机数码&#39;,&#39;小手机&#39;);insert into category values(null,&#39;鞋靴箱包&#39;,&#39;包包&#39;);insert into category values(null,&#39;香烟酒水&#39;,&#39;黄鹤楼,茅台&#39;);insert into category values(null,&#39;馋嘴零食&#39;,&#39;卫龙辣条,周黑鸭&#39;);insert into product values(null,&#39;锤子&#39;,2999,&#39;可以砸榴莲的手机&#39;,1);insert into product values(null,&#39;小米&#39;,1599,&#39;为发烧而生&#39;,1);insert into product values(null,&#39;李宁&#39;,99,&#39;不走寻常路&#39;,2);insert into product values(null,&#39;耐克&#39;,399,&#39;just do it&#39;,2);insert into product values(null,&#39;黄鹤楼&#39;,20,&#39;饭后一根烟,胜做活神仙&#39;,3);insert into product values(null,&#39;卫龙辣条&#39;,5,&#39;卫龙辣条加料不加价&#39;,4);insert into product values(null,&#39;老干妈辣椒酱&#39;,9,&#39;永远不变的味道&#39;,4);insert into product values(null,&#39;老干爹辣椒酱&#39;,19,&#39;永远不变的味道&#39;,4);insert into product values(null,&#39;黄鹤楼&#39;,20,&#39;饭后一根烟,胜做活神仙&#39;,3); 1234&#x2F;*基本语法：select [distinct]*[列名1, 列名2] from 表 [where 条件]*&#x2F; 简单查询12345678910# 🌰# 1. 查询所有商品select * from product;# 2. 查询商品名和商品价格select pname, price from product;# 3. 别名查询，使用关键字 as，as 可以省略select * from product as p; # 表别名select pname as pn from product; # 列别名# 4. 去重复值select distinct price from product; 条件查询123456789101112131415161718192021222324&#x2F;*where 后的条件写法：1. 比较运算符：&gt;(大于), &lt;(小于), &#x3D;(等于), &gt;&#x3D;(大于等于), &lt;&#x3D;(小于等于), !&#x3D;(不等于), &lt;&gt;(不等于，老的写法)2. 逻辑运算符：or(或), and(与)3. is null ： 专门用来判断是否为空4. is not null： 专门用来判断是否非空5. like 模糊查询： _ ：代表一个字符 % ：代表任意个字符6. in 在某个特定数据中取值7. between 在给定范围内取值*&#x2F;# 1. 查询商品名称为十三香的商品的所有信息select * from product where pname &#x3D; &#39;十三香&#39;;# 2. 查询商品价格大于 60 元的所有商品信息select * from product where price &gt; 60;# 3. 查询商品价格大于 60 元且分类为 2 的所有商品信息select * from product where price &gt; 60 and cno &#x3D; 2;# 4. 查询商品名称中带有 新 字的商品信息select * from product where pname like &#39;%新%&#39;;# 5. 查询商品pid 为2,5,8的数据select * from product where pid in (2, 5, 8)# 6. 查询商品pid 在 2 与 8 之间的数据select * from product where pid between 2 and 8; 排序查询123456789# asc 升序， desc 降序# order by 列 [asc|desc]# 🌰# 1. 查询所有商品，按价格进行排序，默认升序select * from product order by price;# 2. 查询名称含有 新 的商品，且按价格降序排序select * from product where pname like &#39;%新%&#39; order by price desc; 聚合查询123456789101112131415&#x2F;*sum ： 和avg ： 平均值max ： 最大值min ： 最小值count ： 个数*&#x2F;# 🌰# 1. 获取所有商品的价格总和select sum(price) from product;# 2. 获取所有商品的平均价格select avg(price) from product;# 3. 获取所有商品的个数select count(*) from product; 分组查询12345678# group by 列# having 关键字可以让我们筛选分组后的各种数据# 🌰# 1. 根据 cno 字段分组，分组后统计各组的个数select cno, count(*) from product group by cno;# 2. 根据 cno 字段分组，分组后统计各组的平均价格，且平均价格大于 60select cno, avg(price) from product group by cno having avg(price) &gt; 60; 分页查询123456# limit ?, ?# 第一个 ？表示跳过前面的多少条，第二个 ？表示返回多少条# 🌰# 查询从第二条开始的两条商品信息，即跳过第一条，返回两条select * from product limit 1, 2; 多表查询准备工作 首先，介绍一下，表之间的关系，约束如何表示 123456789101112&#x2F;*一共 5 大约束： 1. 主键约束：primary key 非空且唯一 2. 唯一约束：unique 唯一可以为空 3. 非空约束：not null 不能为空 4. 检查约束：check(条件) mysql中没有设置检查约束，可以直接忽略 5. 外键约束：foreign key 约束从表中的记录必须参考主表 1-3 很好理解，4我们不做考虑，简要描述 5 的写法和用法*&#x2F;# 下面的建表语句中 该表的 cno 值必须依赖 category 表中的 cid 值foreign key(cno) references category(cid) 为了后面的 🌰 方便，准备了一份数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 用户表 (用户的ID,用户名,密码,手机)create table user( uid int primary key auto_increment, name varchar(10), password varchar(20), mobile varchar(11) ); # 订单表 (订单编号,总价,订单时间 外键--&gt;用户的ID)create table orders( oid int primary key auto_increment, total double, otime timestamp, uno int, foreign key(uno) references user(uid)); # 商品分类表(分类ID,分类名称,分类描述)create table category( cid int primary key auto_increment, cname varchar(20), cdesc varchar(50));# 商品表 (商品ID, 商品名称,商品价格,商品描述,外键cno)create table product( pid int primary key auto_increment, pname varchar(10), price double, pdesc varchar(50), cno int, foreign key(cno) references category(cid));# 订单项: 中间表(订单ID,商品ID,商品数量,订单项总价) create table orderitem( ono int, pno int, num int, subtotal double, foreign key(ono) references orders(oid), foreign key(pno) references product(pid) ); # 准备数据: 假设张三用户注册insert into user values(1,&#39;zs&#39;,&#39;123&#39;,&#39;110&#39;);# 准备数据: 插入分类表的数据insert into category values(1,&#39;手机数码&#39;,&#39;小手机&#39;);insert into category values(2,&#39;鞋靴箱包&#39;,&#39;包包&#39;);insert into category values(3,&#39;香烟酒水&#39;,&#39;黄鹤楼,茅台&#39;);insert into category values(4,&#39;馋嘴零食&#39;,&#39;卫龙辣条,周黑鸭&#39;);insert into category values(5,&#39;电脑办公&#39;,&#39;联想电脑外星人&#39;);# 准备数据 : 插入商品表的数据insert into product values(1,&#39;锤子&#39;,2999,&#39;可以砸榴莲的手机&#39;,1);insert into product values(2,&#39;小米&#39;,1599,&#39;为发烧而生&#39;,1);insert into product values(3,&#39;李宁&#39;,99,&#39;不走寻常路&#39;,2);insert into product values(4,&#39;耐克&#39;,399,&#39;just do it&#39;,2);insert into product values(5,&#39;黄鹤楼&#39;,20,&#39;饭后一根烟&#39;,3);insert into product values(6,&#39;黄鹤楼&#39;,20,&#39;饭后一根烟&#39;,3);insert into product values(7,&#39;卫龙辣条&#39;,5,&#39;卫龙辣条加料不加价&#39;,4);insert into product values(8,&#39;老干妈辣椒酱&#39;,9,&#39;永远不变的味道&#39;,4);insert into product values(9,&#39;老干娘辣椒酱&#39;,null,&#39;永远不变的味道&#39;,4);insert into product values(10,&#39;热干面&#39;,10,&#39;大武汉热干面&#39;,null);# 准备数据: 假设张三在我们的商城下两个订单 # zs买东西: # 1号订单: # 锤子: 1 10 29990 # 李宁: 3 2 198 # 向 订单表 插入1号订单信息(订单编号,订单总价,订单时间,用户编号) insert into orders values(1,30000,null,1); # 向 订单项表 插入1号订单包含的商品信息(订单编号,商品编号,商品数量,商品小计)insert into orderitem values(1,1,10,29990);insert into orderitem values(1,3,2,198); # 2号订单: # 卫龙辣条: 7 10 50 # 老干妈辣椒酱:8 2 18 # 李宁: 3 1 99 # 向 订单表 插入2号订单信息(订单编号,订单总价,订单时间,用户编号) insert into orders values(2,150,null,1); # 向 订单项表 插入2号订单所包含的商品信息(订单编号,商品编号,商品数量,商品小计)insert into orderitem values(2,7,10,50);insert into orderitem values(2,8,2,18);insert into orderitem values(2,3,1,99); 交叉连接查询笛卡尔积：两张表的乘积，查询的结果没有什么实际意义 12# product 表和 category 的笛卡尔积select * from product, category; 内连接查询隐式内连接12# product 表中 cno 等于 cateory表中 cid 的数据select * from product p, category c where p.cno &#x3D; c.cid; 显式内连接12# inner join 关键字 内连接select * from product p inner join category c on p.cno &#x3D; c.cod; 外连接查询左外连接以左表为基础，将左表中所有的记录都查询出来，如果没有对应的记录，就用 null 填充 1select * from product p left outer join category c on p.cno &#x3D; c.cid; 右外连接以右表为基础，将右表中所有的记录都查询出来，如果没有对应的记录，就用 null 填充 1select * from product p right outer join category c on p.cno &#x3D; c.cid; 子查询 为了后面的 🌰 方便，准备了一份数据 123456789101112131415161718192021222324252627282930313233343536373839# 员工信息表create table emp( empno int comment &#39;员工编号&#39;, ename varchar(50) comment &#39;员工姓名&#39;, job varchar(50) comment &#39;员工工作&#39;, mgr int comment &#39;员工经理编号&#39;, hiredate date comment &#39;员工入职日期&#39;, sal decimal(7,2) comment &#39;员工工资&#39;, comm decimal(7,2) comment &#39;员工奖金&#39;, deptno int comment &#39;员工所处部门&#39;);insert into emp values(7369,&#39;SMITH&#39;,&#39;CLERK&#39;,7902,&#39;1980-12-17&#39;,800,NULL,20);insert into emp values(7499,&#39;ALLEN&#39;,&#39;SALESMAN&#39;,7698,&#39;1981-02-20&#39;,1600,300,30);insert into emp values(7521,&#39;WARD&#39;,&#39;SALESMAN&#39;,7698,&#39;1981-02-22&#39;,1250,500,30);insert into emp values(7566,&#39;JONES&#39;,&#39;MANAGER&#39;,7839,&#39;1981-04-02&#39;,2975,NULL,20);insert into emp values(7654,&#39;MARTIN&#39;,&#39;SALESMAN&#39;,7698,&#39;1981-09-28&#39;,1250,1400,30);insert into emp values(7698,&#39;BLAKE&#39;,&#39;MANAGER&#39;,7839,&#39;1981-05-01&#39;,2850,NULL,30);insert into emp values(7782,&#39;CLARK&#39;,&#39;MANAGER&#39;,7839,&#39;1981-06-09&#39;,2450,NULL,10);insert into emp values(7788,&#39;SCOTT&#39;,&#39;ANALYST&#39;,7566,&#39;1987-04-19&#39;,3000,NULL,20);insert into emp values(7839,&#39;KING&#39;,&#39;PRESIDENT&#39;,NULL,&#39;1981-11-17&#39;,5000,NULL,10);insert into emp values(7844,&#39;TURNER&#39;,&#39;SALESMAN&#39;,7698,&#39;1981-09-08&#39;,1500,0,30);insert into emp values(7876,&#39;ADAMS&#39;,&#39;CLERK&#39;,7788,&#39;1987-05-23&#39;,1100,NULL,20);insert into emp values(7900,&#39;JAMES&#39;,&#39;CLERK&#39;,7698,&#39;1981-12-03&#39;,950,NULL,30);insert into emp values(7902,&#39;FORD&#39;,&#39;ANALYST&#39;,7566,&#39;1981-12-03&#39;,3000,NULL,20);insert into emp values(7934,&#39;MILLER&#39;,&#39;CLERK&#39;,7782,&#39;1982-01-23&#39;,1300,NULL,10);insert into emp values(7981,&#39;MILLER2&#39;,&#39;CLERK&#39;,7788,&#39;1992-01-23&#39;,2600,500,20);# 部门信息表create table dept( deptno int comment &#39;部门编号&#39;, dname varchar(14) comment &#39;部门的名称&#39;, loc varchar(13) comment &#39;部门所处的位置&#39;);insert into dept values(10, &#39;ACCOUNTING&#39;, &#39;NEW YORK&#39;);insert into dept values(20, &#39;RESEARCH&#39;, &#39;DALLAS&#39;);insert into dept values(30, &#39;SALES&#39;, &#39;CHICAGO&#39;);insert into dept values(40, &#39;OPERATIONS&#39;, &#39;BOSTON&#39;); 单行子查询12# 查询出高于 10 号部门的平均工资的员工信息select * from emp where sal &gt; (select avg(sal) from emp where deptno &#x3D; 10); 多行子查询12# 查询出比 20 号部门任何员工工资高的员工信息 in, not in, any, allselect * from emp where sal &gt; all(select sal from emp where deptno &#x3D; 20); 视图（虚表） 视图其实就是将一条复杂且常用的 SQL 查询语句封装成一张虚表 视图本身不存储任何的数据，所有的数据都存放在原来的表中，所以可以把视图看成是一张逻辑上的表 当原始表数据发生变化的时候，视图中的数据也发生变化 视图这张虚表也可以进行数据更新操作 创建视图123create view 视图名称 as 查询语句;# 1. 视图中的字段名称不能有重复的# 2. 为了方便区分，建议用 v_ 开头表示视图 查看视图12# 该方法不仅可以看到表，也可以看到视图show tables; 使用视图视图的使用方法与表的使用方法一致 删除视图1drop view 视图的名称; 事务 事务其实就是一系列的 SQL 操作，要么都成功，要么都失败，不允许部分执行成功，部分执行失败的情况发生。 事务的特性 ACID 原子性(Atomicity) 一个事务必须被视为一个不可分割的最小单元。 一致性(Consistency) 数据库总是从一个一致性的状态转换到另一个一致性的状态。 隔离性(Isolation) 一个事务的执行，不受其他事务的影响。 持久性(Durability) 事务一旦提交，则其所做的修改会永远保存到数据库中（此时即使系统崩溃，修改的数据也不会丢失）。 事务的使用123456# 开启事务begin;# 提交事务commit;# 回滚事务rollback; 索引 索引是一种排好序的快速查找的数据结构，它帮助数据库高效的查询数据 优点： 提高数据查询的效率，降低数据库的 IO 成本 通过索引对数据进行排序，降低数据排序成本，降低 CPU 的消耗 缺点： 索引本身也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引也要占用空间 虽然索引大大提高了查询的速度，同时反向影响了增删改的操作效率，因为表中数据变化之后，会导致索引内容不准，所以需要更新索引表信息，增加数据库的工作量。 随着业务的不断变化，之前建立的索引可能不满足我们的查询需求，需要消耗我们的时间去更新索引 索引的使用查看索引1show index from 表名; 创建索引123# 如果指定字段是字符串，需要指定长度，长度最好与定义字段时一致# 字段类型如果不是字符串，可以不填长度create index 索引名称 on 表名(字段名(长度)); 删除索引1drop index 索引名称 on 表名;","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"MySQL","slug":"Coding/MySQL","permalink":"https://askeynil.github.io/categories/Coding/MySQL/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://askeynil.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://askeynil.github.io/tags/MySQL/"}]},{"title":"PyQt5 的学习与使用","slug":"PyQt5 的学习与使用","date":"2019-08-07T01:00:00.000Z","updated":"2020-11-04T10:55:07.303Z","comments":true,"path":"2019/29129922.html","link":"","permalink":"https://askeynil.github.io/2019/29129922.html","excerpt":"PyQt5是一条 Python 的 GUI 开发框架 PyQt5 的安装 pip3 install PyQt5 在终端中输入 python3进入 python 解释器 输入以下代码from PyQt5 import QtWidgets 如果显示执行成功，即表示安装完成 PyQt 的模块介绍PyQt 在运行时，有几句固定代码 导入需要的库 import sys from PyQt5 import QtWidgets # 这部分导入根据需要使用的框架进行导入 创建和停止应用程序 app = QtWidgets.QApplication(sys.argv) # 创建应用程序 ... # 期间是程序需要执行的代码，比如创建界面和各种逻辑 sys.exit(app.exec()) # 退出应用程序","text":"PyQt5是一条 Python 的 GUI 开发框架 PyQt5 的安装 pip3 install PyQt5 在终端中输入 python3进入 python 解释器 输入以下代码from PyQt5 import QtWidgets 如果显示执行成功，即表示安装完成 PyQt 的模块介绍PyQt 在运行时，有几句固定代码 导入需要的库 import sys from PyQt5 import QtWidgets # 这部分导入根据需要使用的框架进行导入 创建和停止应用程序 app = QtWidgets.QApplication(sys.argv) # 创建应用程序 ... # 期间是程序需要执行的代码，比如创建界面和各种逻辑 sys.exit(app.exec()) # 退出应用程序 PyQt5的主要模块 模块 解释 QtCore 包括了核心的非 GUI 的功能。主要和时间、文件、文件夹、各种数据、流、URLS、mime 类文件、进程和线程。 QtGui 包括了窗口系统、事件处理、2D 图像、基本绘画、字体和文字类 QtWidgets 包括了一系列创建桌面应用的 UI元素 QtMultimedia 负责处理多媒体的内容和调用摄像头 QtBluetooth 负责查找和连接蓝牙 QtNetwork 负责网络编程 QtPositioning 负责定位相关 Enginio 包含了通过客户端进入和管理 Qt Cloud QtWebSockets 实现了 WebSocket 协议 QtWebKit 包含了一个基于 WebKit2 的 web 浏览器 QtWebKitWidgets 包含了基于 QtWidgets 的 WebKit1的类 QtXml 负责处理 xml QtSvg 负责显示 SVG 内容 QtSql 提供了处理数据库的工具 QtTest 提供了测试 PyQt5 应用的工具 设置图标、标题和窗口大小123456789101112131415161718192021222324from PyQt5.QtWidgets import *from PyQt5.QtGui import QIconimport sys# 创建应用程序app = QApplication(sys.argv)# 设置程序图标app.setWindowIcon(QIcon(&quot;qq.png&quot;))# 创建窗口组件window = QMainWindow()# 设置窗口大小window.resize(300, 300)# 设置程序标题window.setWindowTitle(&quot;这是一个 QMainWindow 案例&quot;)# 显示窗口组件window.show()# 退出应用程序sys.exit(app.exec()) 屏幕坐标系 屏幕和窗口都是以坐标确定位置的 屏幕左上角为坐标原点 屏幕左上角向右为 x 轴正向 屏幕左上角向下为 y 轴正向 窗口在屏幕中的位置坐标是以窗口左上角位置确定的 将窗口移动到屏幕中心窗口需要居中屏幕时 x 和 y的坐标应该为 x = (屏幕宽度 - 窗口宽度) / 2 y = (屏幕高度 - 窗口宽度) / 2 移动到中心的方法 方法 调用对象 方法说明 screenGeometry() QDesktopWidget() 获取屏幕尺寸 geometry() QWidget() 获取窗口尺寸 move(x, y) QWidget() 移动到指定的位置 移动窗口的核心代码 123456789# 获取屏幕尺寸screen = QDesktopWidget().screenGeometry()# 获取窗口尺寸size = window.geometry()# 移动到屏幕中心window.move((screen.width() - size.width()) / 2, (screen.height() - size.height()) / 2) 气泡提示在界面设计的时候常常会用到的一个提示气泡，只要对任意一个 widget 设置一个属性就可以做到：setToolTip(msg) msg就是你要设置的气泡提示 常用控件QLabelQLabel 可以显示不可编辑的文本或图片，也可以设置一个 gif 动画 QFont 用来设置字体样式和字体大小 常用方法： 方法 解释 __init__(str, parent: QWidget = None, flags: Union[WindowFlags, WindowType] = Qt.WindowFlags()) 初始化方法，str 也可以不传，初始化之后设置也可以 setText(str) 设置文本内容 setFont(QFont) 设置字体样式和大小 setPixmap(QPixmap) 设置图片 文本框控件QLineEditQLineEdit 是单行文本框控件 常用方法： 方法 解释 setEchoMode(EchoMode) QLineEdit.Normal 正常显示所输入字符QLineEdit.NoEcho 不显示任何输入的字符QLineEdit.Password 显示与平台相关的密码掩码字符QLineEdit.PasswordEchoOnEdit 在编辑时显示字符，负责显示密码类型的输入 setPlaceholderText(str) 设置文本框占位文字，即当有文字输入时，该文字会消失 setText(str) 设置文本框内容 setMaxLength(int) 设置文本框所允许输入的最大字符数 QTextEditQTextEdit 是多行文本框控件 QTextEdit 可以显示多行文本内容，当文本内容超过控件范围时，会显示水平或者竖直的滚动条 QTextEdit 不仅可以显示文本，还可以显示 HTML 文档 常用方法 方法 解释 setPlainText(str) 设置多行文本框的文字内容 toPlainText() → str 返回多行文本框的文字内容 setHtml(str) 设置文本框的内容为 HTML 文档 toHtml() → str 返回多行文本框的 HTML 文档内容 clear() 清空多行文本框内容 按钮控件信号和槽信号和槽机制是 QT 的核心机制，它是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性 信号和槽是用来在对象间传递数据的方法：当一个特定事件发生的时候，signal 会被emit出来，slot调用是用来响应对应的 signal的 Qt 对象已经包含了很多预定义的 signal，Qt 对象也包含了很多预定义的槽函数 信号 当对象的状态发生改变的时候，信号就由该对象发射出去 当一个信号被发射、与其关联的槽函数被立刻执行，发射该信号的对象并不知道是哪个在接收在这个信号。再这样保证了对象与对象之间的低耦合。 如果信号和多个槽函数相关联，当信号被发射时，这些槽函数的执行顺序将会是随机的，不确定的。 槽 用于接收信号，而且槽只是普通的成员函数。当和槽连接的信号被发射时，槽就会被调用。 一个槽并不知道时候有任何信号与自己相连。 信号和槽的绑定通过调用 QObject 对象的 connect 函数来将对象的信号与另外一个对象的槽函数相关联，当发射者发射信号时，接受者的槽函数将被调用。 信号和槽连接通过 connect 方法 槽函数可以是成员方法或者 lambda 表达式 QPushButtonQPushButton是一种普通的按钮，可以响应一些事件 QRadionButtonQRadionButton是单选按钮，它提供了一组可供选择的按钮和文本标签，用户可以选择其中一个选项 标签用于显示对应的文本信息 单选框选中的信号时：toggled QCheckBoxQCheckBox 提供一组带文本标签的复选框，用户可以选择多个选项 复选框选中的信号也为：toggled 对话框控件对话框是为了更好的实现人与程序的交互 QMessageBoxreply = QMessageBox.information() reply = QMessageBox.question() 两个提示框参数一模一样，唯一的差别就是提示框上显示的图片不一样 QInputDialogQInputDialog是一个标准对话框，由一个文本框和两个按钮(OK按钮和 Cancel 按钮组成) 布局一个窗口中可以有多个控件，所谓布局，就是将多个控件按我们需要的方式展示出来 布局大致可以分为：绝对布局，水平布局，竖直布局，网格布局，表单布局。 布局方法 布局中可以添加控件，使用 addWidget() 方法 布局中可以添加布局，使用 addLayout()方法 绝对布局绝对布局就是通过在窗口程序中指定每一个控件的显示坐标和大小来实现的 优点： 可以直接定位每一个控件的位置 缺点 如果改变窗口大小，控件的大小和位置不会随之改变 如果修改布局，比如新增一个控件，必须全部重新布局，很繁琐 水平布局在水平布局中，按照从左往右的顺序添加控件。使用 QHBoxLayout 进行布局 竖直布局在竖直布局中，按照从上往下的方式添加控件。使用 QVBoxLayout 进行布局 表单布局表单布局是 label-field 式的表单布局，顾名思义，就是实现表单方式的布局，添加控件的方法为addRow(label, widget)","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://askeynil.github.io/tags/PyQt5/"}]},{"title":"Python 基础2","slug":"Python 基础 2","date":"2019-08-06T07:00:00.000Z","updated":"2020-11-04T10:55:07.303Z","comments":true,"path":"2019/cc28d4d3.html","link":"","permalink":"https://askeynil.github.io/2019/cc28d4d3.html","excerpt":"函数所谓函数，就是把一个具有独立功能的代码块组织成一个整体，在需要的时候调用。 函数的使用一般包含两个步骤： 定义函数：在函数中编写代码、实现功能 调用函数：执行编写的代码 好的函数，可以提高代码编写的效率，以及代码的复用性。 函数的定义12def 函数名(): 执行的代码 函数的定义规范： def是define的缩写 函数的名称应该能简单明确的表明函数的功能，比如 min()很清晰的表达了该函数就是用来求最小值的 函数名称的命名应该符合标识符的命名规则： 只能由字母、数字和下划线组成 不能以数字开头 不能跟关键字重名 函数的执行过程 代码执行到函数定义时，不会走到函数的内部，只是将该函数名作为一个标识符，添加到内存中 当调用函数时，才会从内存中去查询该函数，并执行函数内部的相关代码","text":"函数所谓函数，就是把一个具有独立功能的代码块组织成一个整体，在需要的时候调用。 函数的使用一般包含两个步骤： 定义函数：在函数中编写代码、实现功能 调用函数：执行编写的代码 好的函数，可以提高代码编写的效率，以及代码的复用性。 函数的定义12def 函数名(): 执行的代码 函数的定义规范： def是define的缩写 函数的名称应该能简单明确的表明函数的功能，比如 min()很清晰的表达了该函数就是用来求最小值的 函数名称的命名应该符合标识符的命名规则： 只能由字母、数字和下划线组成 不能以数字开头 不能跟关键字重名 函数的执行过程 代码执行到函数定义时，不会走到函数的内部，只是将该函数名作为一个标识符，添加到内存中 当调用函数时，才会从内存中去查询该函数，并执行函数内部的相关代码 函数的参数函数的参数，可以在调用函数时传递给函数内部进行使用，参数的作用就是为了增加函数的通用型，增强函数的功能。 参数的定义以及调用格式123456# 函数的定义def 函数名(参数): 执行的代码# 函数的调用函数名(参数) 函数参数可以用多个在函数定义的时候，可以有多个参数传递，同时也接收多个参数 形参和实参形参的全称为“形式参数”，由于它不是实际存在的变量，所以又称为虚拟变量。形参就是在函数被调用的时候用来接收实参的数据的变量 实参全称为“实际参数”，是在调用时传递给函数的参数。 在调用函数时，实参将赋值给形参。因而，必须注意实参的个数、类型与形参一一对应，并且实参必须要有确定的值 实参可以是常量、变量、表达式、函数等，无论实参是何种类型，在函数进行调用的时候，它们都必须有一个具体确定的值。 形参的作用域 ​ 作用域，通常来说，一段程序代码中所用到的名字并不中是有效、可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域 形参的作用域只在定义函数的代码块中，一旦超出该范围就不能继续使用了 不同的函数中，可以使用相同的形参名，不会相互影响 作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突 函数间的形参是不能相互使用的 函数的返回值在实际开发中，有时候我们希望一段函数在执行结束后，能告诉调用者一个结果，以便调用者根据这个结果进行下一步的处理。 在函数中我们使用 return 关键字来返回结果，调用函数的一方，可以使用变量来接收函数的返回结果 函数的四种类型 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 函数的嵌套调用在一个函数内，我们又调用了另一个函数，这就是函数的嵌套调用。 局部变量和全局变量局部变量 局部变量就是定义在函数内部的变量 在不同的函数中，可以定义相同的名字的局部变量，但是各用个的不会产生影响 局部变量的作用域只在该函数内部 局部变量的目的是为了存储需要临时保存的数据 全局变量 全局变量是定义在所以函数外的变量 全局变量在整个 py 文件中都可以访问的 函数内修改全局变量之前需要用 global进行声明，否则会出错 模块 模块是 Python 程序框架中一个核心概念 模块就好比是工具包，要想使用该工具包中的工具，就需要用 import来导入整个模块 每一个以.py 结尾的 Python 源代码文件都是一个模块 在模块中定义的全局变量、函数都是模块能提供给外界直接使用的工具 模块的命名规则 只能由字母、数字和下划线组成 不能以数字开头 不能以关键字重名 函数式编程函数可以作为函数的参数，也可以作为函数的返回值，这就是函数式编程。 常见的编程范式： OOP 面向对象编程 FP 函数式编程 POP 面向过程编程 Python支持函数式编程，支持高阶函数和 lambda 表达式 lambda 表达式lambda也称为匿名函数，这种函数得名于省略了用 def 声明函数的标准步骤 用法： lambda 参数: 表达式 高阶函数高级函数的意思就是把函数当成参数传递的一种函数。 Python 系统内置的高阶函数有： sort() map() filter() reduce() sort定义： sort(*, key=None, reverse=False) 该函数根据 key 中的函数来进行排序 eg: q：元素按长度从小到大排序 a： 123456l = [&quot;abd&quot;, &quot;dsad&quot;, &quot;ds&quot;, &quot;fafas&quot;,&quot;dasdsad&quot;]l.sort(key=lambda item: len(item))print(l)# 控制台打印如下[&#x27;ds&#x27;, &#x27;abd&#x27;, &#x27;dsad&#x27;, &#x27;fafas&#x27;, &#x27;dasdsad&#x27;] map定义： map(function, iterable, ...) 该函数将每个 iterable 进行 funtion 中的操作 q：将列表中的元素编程它的平方 a： 123456l = [1, 2, 3, 4, 5, 7, 8, 9]l = map(lambda item: item ** 2, l)print(list(l))# 控制台打印如下[1, 4, 9, 16, 25, 49, 64, 81] filter定义： filter(function, iterable) 该函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 q：找出列表中所有的 1 a： 123456l = [1, 2, 1, 4, 5, 1, 8, 9]l = filter(lambda item: item == 1, l)print(list(l))# 控制台打印如下[1, 1, 1] reduce定义： reduce(function, iterable[, initializer]) 该函数会对参数序列中元素进行累积 q：求列表所有元素的和 a： 1234567from functools import *l = [1, 2, 3, 4, 5, 6, 7, 8, 9]l = reduce(lambda x, y: x + y, l)print(l)# 控制台打印如下45 注意在 Python3 中移除了 reduce，需要在 functools 包中导入才能使用 切片 切片就是根据步长从原序列中取出一部分元素组成的新序列 切片只适用于字符串、列表、元组 切片的格式：需要切片的元素[开始索引:结束索引:步长] 切片的注意事项： 指定的区间属于左闭右开区间，包括开始索引，不包括结束索引 步长默认为 1，可以省略 步长也可以是负数，代表了逆序切片 从头开始，开始索引可以省略，冒号不能省略 到末尾结束，结束索引可以省略，冒号不能省略 🌰： 1234567# 将 123456789 切出 123str1 = &quot;123456789&quot;str1 = str1[0:3]print(str1)# 打印123 我们正常使用的即为正序索引，倒序索引指的是从右往左计算索引，最右边的索引值为-1，依次递减 推导式列表的推导式所谓列表的推导式，就是指轻量级循环创建列表 列表推导式的格式如下： l = [计算公式 for 循环 if 判断] 🌰： 12# 创建一个1 到 100 数据的数组l = [item for item in range(1, 101)] 集合的推导式所谓集合的推导式，就是指轻量级循环创建集合 列表推导式的格式如下： l = &#123;计算公式 for 循环 if 判断&#125; 🌰： 12# 创建一个1 到 100 数据的集合l = &#123;item for item in range(1, 101)&#125; 字典的推导式所谓字典的推导式，就是指轻量级循环创建字典 列表推导式的格式如下： l = &#123;key: value for 循环 if 判断&#125; 🌰： 12# 创建一个 &#123;1:1, 2:2, ..., 100,100&#125; 的字典l = &#123;item:item for item in range(1, 101)&#125; 数据类型之间的转换 函数 描述 int(x, [base]) 将 x按照 base 进制转换为整型，默认 10 进制 float(x) 将 x转换为一个浮点数 str(x) 将 x 转换为一个字符串 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 将序列 s 转换为一个可变集合 dict(d) 创建一个字典 frozenset(s) 将序列 s 转换为一个不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为一个整数 hex(x) 将一个整数转换为一个 16 进制字符串 oct(x) 将一个整数转换为一个 8 进制字符串","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"}]},{"title":"Python 基础1","slug":"Python 基础","date":"2019-08-06T03:00:00.000Z","updated":"2020-11-04T10:55:07.303Z","comments":true,"path":"2019/55218569.html","link":"","permalink":"https://askeynil.github.io/2019/55218569.html","excerpt":"变量变量的命名规则 只能有数字，字母，下划线（_）组成 不能以数字开头 不能是关键字 区分大小写 命名规范 下划线命名法 my_first_name my_last_name 驼峰命名法 大驼峰 MyFirstName MyLastName 小驼峰 myFirstName myLastName 变量类型变量类型分为：数值型和非数值型 数值型 数据类型 描述 int 整型 float 浮点型 bool 布尔型 complex 复数型","text":"变量变量的命名规则 只能有数字，字母，下划线（_）组成 不能以数字开头 不能是关键字 区分大小写 命名规范 下划线命名法 my_first_name my_last_name 驼峰命名法 大驼峰 MyFirstName MyLastName 小驼峰 myFirstName myLastName 变量类型变量类型分为：数值型和非数值型 数值型 数据类型 描述 int 整型 float 浮点型 bool 布尔型 complex 复数型 非数值型 数据类型 描述 str 字符串 list 列表 tuple 元组 set 集合 dict 字典 变量类型的特征和获取在Python中定义变量不需要指定数据类型，变量的类型可以在使用过程中随时变化，以最后一次=操作为准 当我们需要获取该变量的类型的时候，可以使用 type获取当前变量的类型 算数运算符 运算符 描述 + 加 - 减 * 乘 / 除 // 取整除 % 取余数 ** 幂 不同变量类型之间的运算 数值型变量之间可以直接计算 字符串之间使用+拼接字符串 字符串变量和整型使用*重复拼接相同的字符串 数值型变量和字符串不能进行其他计算 赋值运算符 运算符 描述 = 赋值 += 加等于(a += b等同于a = a + b) -= 减等于(a -= b等同于a = a - b) *= 乘等于(a *= b等同于a = a * b) /= 除等于(a /= b等同于a = a / b) //= 整除等于(a //= b等同于a = a // b) %= 模等于(a %= b等同于a = a % b) **= 幂等于(a **= b等同于a = a ** b) 比较运算符 运算符 描述 == 等于 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 逻辑运算符 运算符 描述 and 逻辑与 or 逻辑或 not 逻辑非 运算符优先级 单目运算符：只需要一个数据运算的运算符，比如 not 双目运算符：需要两个数据运算的运算符 总的来说：单目运算符的优先级高于双目运算符 运算符 描述 ** 幂（最高优先级） * / % // 乘、除、取余数、取整除 + - 加、减 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 not or and 逻辑运算符 输入输出操作输出函数 普通输出 格式化输出 print()函数 格式化输出格式 格式化字符串 含义 %s 字符串 %d 有符号的十进制整数，%06d表示不足 6 位以 0 补齐 %f 浮点数，%.2f 表示小数后只显示两位 %% 输出% ###输入函数 获取用户从键盘上输入的信息，需要使用 input函数，不管用户输入了任何内容，Python 都会认为是一个字符串 转换输入函数使用强制转换来使得用户输入的字符串转换为我们需要的数据类型 float()转换为浮点类型 int()转换为整型 条件控制语句if 程序满足特定的条件才能执行的特定代码 条件控制语句使用 if 关键字 格式如下： 1234if 条件: 条件为真时，要做的事情else: 条件为假时，要做的事情 if...elif...else 格式如下： 123456if 条件1: 条件1为真时，要做的事情elif 条件2: 条件1为假且条件2为真时，要做的事情else: 以上条件均为假时，要做的事情 if 嵌套在实际开发中，有多个条件判断的需求，就需要使用 if 嵌套 格式如下： 123if 条件1: if 条件2: 条件1，条件2均为真时，要做的事情 循环控制语句 while和 for循环的作用就是让代码执行指定的重复的代码 while循环while循环 主要用在遍历指定次数的时候使用 格式如下： 1234while 条件: 条件为真时，要做的事情 ... 修改条件 条件主要控制循环何时结束，注意如果条件一直不能为假，则该循环就为死循环，死循环会一直执行该重复的指令，无法终止。 for循环for循环 主要用在遍历容器类中的元素的时候使用 格式如下： 12for 临时变量 in 容器: 循环满足条件需要执行的代码 rangerange()可以理解为数学中左闭右开的区间，常常使用在 for 语句中 break 和 continue语句break语句和 continue语句是专门在循环中使用的关键字 当某一条件满足时，执行了 break 语句，这层循环将不在进行，会直接退出当层循环（后面会讲到循环嵌套，break 只会跳出一层循环） 当某一条件满足时，执行了 continue 语句，会直接跳过该次循环，直接到下一次循环中（在循环嵌套中，同样只会跳到该层循环的下次循环中，其他层次的循环不会受到影响） 循环嵌套循环嵌套的意思就是循环中还有循环 循环结合 else循环后面跟了一个 else 语句，该语句会在循环正常结束后执行，但是如果循环是通过 break语句进行结束的，该 else 中的语句就不会执行了 高级数据类型所有的非数值型变量都有以下特点： 都是一个序列 sequence，也可以理解为容器 都可以取值[0] （集合除外） 都可以用 for ... in ... 遍历 计算长度、最大/最小值、比较、删除 连接+和重复* 切片 字符串 字符串就是一串字符，是编程语言中表示文本的数据类型 在Python 中可以使用一对双引号 &quot;&quot; 或一对单引号 &#39;&#39; 来定义一个字符串 虽然有转义字符帮助我们转义&quot;和&#39;，但是在开发中 在字符串内部有使用&quot;的需求，一般使用&#39;来定义字符串 在字符串内部有使用&#39;的需求，一般使用&quot;来定义字符串 可以使用索引来获取字符串指定位置的字符，索引从 0 开始 Python 中可以使用多行字符串，多行字符串的定义方式与多行注释的方式一致，使用三个&quot;&quot;&quot;进行定义 123str1 = &quot;&quot;&quot;这是一个多行字符串的🌰&quot;&quot;&quot; 字符串操作判断操作 方法 说明 isalpha() 如果一个字符串所有字符都是字母的时候，返回 True isdecimal() 如果一个字符串所有字符都是数字的时候，返回 True islower() 如果一个字符串所有字符都是小写字母的时候，返回 True isupper() 如果一个字符串所有字符都是大写字母的时候，返回 True startwith(str) 检查一个字符串是以 str 开头的时候，返回 True endswith(str) 检查一个字符串是以 str 结尾的时候，返回 True 查找和替换 方法 说明 find(str, start = 0, end = len(string)) 查找 str 是否在这个字符串中，如果在则返回开始的索引值，查不到则返回-1 rfind(str, start = 0, end = len(string)) 类似find()，但是是从右边开始查找 index(str, start = 0, end = len(string)) 跟find()类似，但是查不到会抛出异常 rindex(str, start = 0, end = len(string)) 跟rfind()类似，但是是从右边开始查找 replace(old_str, new_str, num=string.count(old)) 返回一个新的字符串，把 old_str 替换成 new_str 拆分和连接 方法 说明 partition(str) 返回一个元组，把字符串根据 str 分隔成 3 元素的元组 rpartition(str) 类似partition()，但是是从右边开始查找 split(str, num) 根据 str 分隔字符串到一个列表中，num 是分隔的次数 splitlines() 返回列表，根据行分隔 string1 + string2 拼接两个字符串 join(seq) 返回一个字符串，以 str作为分隔符，将 seq 中所有元素合并成一个新的字符串 大小写转换 方法 说明 lower() 将所有字符转化为小写 upper() 将所有字符转化为大写 文本对齐 方法 说明 ljust(width) 返回一个新字符串，在左边填充直到字符串长度为 width，默认填充空格 rjust(width) 返回一个新字符串，在右边填充直到字符串长度为 width，默认填充空格 center(width) 返回一个新字符串，在两边填充直到字符串长度为 width，默认填充空格 去除空白符 方法 说明 lstrip() 返回新字符串，截掉左边的空白字符，或指定字符 rstrip() 返回新字符串，截掉右边的空白字符，或指定字符 strip() 返回新字符串，截掉两边的空白字符，或指定字符 list 列表list列表将是我们学习 Python 中使用最频繁的一个数据类型，该类型用来存储一串数据，存储的数据我们称之为元素 列表的定义 列表用[]定义，元素之间用,分隔开即可 列表中可以有不同的数据类型，每个元素可以是任意类型 列表的访问访问列表一般通过索引的方式，这里要注意的是，索引是从 0 开始的，即列表中的第一个元素的索引为 0 当然，我们最常用的还是用循环去遍历列表中的元素，通过 for 和 while 都可以，建议使用 for，看起来会更加简洁，但是在一些需要知道索引的情况下，while 也不失为一种优秀的选择。while 的循环条件比 for 来的更加灵活 列表的操作增加操作 方法 说明 append(item) 在末尾追加item insert(index, item) 在 index 位置插入 item extend(Iterable) 将可迭代对象中的元素添加到列表中 删除操作 方法 说明 del List(index) 删除List的指定 index 的元素 remove(item) 删除第一个出现的指定item pop() 删除末尾数据，并返回被删除的元素 pop(index) 删除指定索引的元素，返回被删除的元素 clear() 清空列表 修改操作 List[index] = item # 修改 List中指定 index 的元素为 item 查询操作 方法 说明 List[index] 查询 List指定 index 的元素，index 不存在时将会抛出异常 index(item) 根据 item 查找指定 List 中的该 item 的位置，没查到的时候会抛出异常 count(item) item在列表中出现的次数 len(List) List 的长度 if item in List: 检查List 中是否包含 item 排序操作 方法 说明 sort() 升序 sort(reverse = True) 降序 reverse() 逆序，反转 最值操作 方法 说明 max() 最大值 min() 最小值 列表嵌套列表嵌套和上文讲到的循环嵌套类似，即在列表中还有列表，即列表的元素还是一个列表，这就是列表嵌套，在实际使用中经常出现，eg:a = [[1,2,3],[4,5,6],[7,8,9]]这就是一个简单的两个列表嵌套 tuple 元组元组和列表类似，不同的地方在与元组不允许对内部的元素进行修改 元素用()定义 用于存储一串数据，元素之间用,分隔 元组的索引从 0 开始 元组的类型：tuple 元组的定义info_tuple = (1, 2, 3, 4) 注意，如果元组中只有一个元素的时候需要在后加一个, eg： a = (10) # 如果这样定义一个一元素元组是错误的，次数的 a 为 int 类型而不是tuple a = (10,) #一元素元组的正确定义方式 元组最大的特点就是不能修改 元组的操作元组的操作和数组的操作类似，只是没有数组的增加，删除，修改，排序操作。 元素的使用场景 作为自动组包的默认类型 自动解包 交换数据 格式化输出 让列表不可被修改，保护数据安全 set集合集合是无序的，且集合中的元素是唯一的 集合一般用来对列表或元组进行去重操作，注意：如果用 set 进行了去重操作，列表或元组中的元素位置将变化，因为 set 是无序的 创建空集合的方式 set1 = set() 集合操作 方法 说明 add() 添加一个元素到集合中 update() 将传入数据拆分，然后添加到集合中 remove() 删除集合中一个元素，如果没有，程序抛出异常 pop() 随机删除一个元素，如果没有元素，程序将抛出异常 discard() 元素存在直接删除，不存在不做任何操作 集合的交集、子集、超集、并集、异或、差集 方法 符号 说明 s1.issubset(s2) s1 &lt; s2 s1 是否是 s2 的子集 s1.issuperset(s2) s1 &gt; s2 s1 是否是 s2 的超集 s1.union(s2) s1 &amp; s2 s1 和 s2 的并集 s1.intersection(s2) s1 &amp; s2 s1 和 s2 的交集 s1.difference(s2) s1 - s2 s1 和 s2 的差集 s1.symmetric_difference(s2) s1 ^ s2 s1 和 s2 的异或 dict 字典dict 是除列表以外 Python 中最灵活的数据类型 字典可以用来存储多个数据 字典用&#123;&#125;定义 字典使用键值对存储数据，键值对之间的关系用,分隔 键 key是索引 值 value是数据 键和值用:进行分隔 值可以是任何数据类型，但键只能是字符串、数字或元组 键必须唯一 字典的操作 分类 方法 说明 增加 dict[key] = value 键不存在时，会添加键值对；键存在时，会修改键值对 dic.setdefault(key, value) 键不存在时，会添加键值对；键存在时，不做任何处理 删除 del dict[key] 删除指定键值对 dict.pop(key) 删除指定键值对，并返回被删除的值 dict.clear() 清空字典 修改 dict[key] = value 键不存在时，会添加键值对；键存在时，会修改键值对 dict.update(key=value) 键不存在时，会添加键值对；键存在时，会修改键值对 查询 dict[key] 根据键取出值，键不存在时，会抛出异常 dict.get(key) 根据键取出值，键不存在时，不会抛出异常 dict.keys() 可进行遍历，获取所有键 dict.values() 可进行遍历，获取所有值 dict.items() 可进行遍历，获取所有（键，值） 公共语法Python 内置函数 函数 描述 备注 len(item) 计算容器中元素个数 del item 删除变量 max(item) 返回容器中元素最大值 字典只比较 key min(item) 返回容器中元素最小值 字典只比较 key 运算符 运算符 描述 支持的数据类型 + 合并 字符串、列表、元组 * 重复 字符串、列表、元组 in 是否存在（字典中判断键） 字符串、列表、元组、集合、字典 not in 是否不存在（字典中判断键） 字符串、列表、元组、集合、字典 &gt; &gt;= == &lt; &lt;= 比较 字符串、列表、元组","categories":[{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"}]}],"categories":[{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/categories/ROS/"},{"name":"Foxy","slug":"ROS/Foxy","permalink":"https://askeynil.github.io/categories/ROS/Foxy/"},{"name":"Coding","slug":"Coding","permalink":"https://askeynil.github.io/categories/Coding/"},{"name":"Git","slug":"Coding/Git","permalink":"https://askeynil.github.io/categories/Coding/Git/"},{"name":"驱动开发","slug":"Coding/驱动开发","permalink":"https://askeynil.github.io/categories/Coding/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"C++","slug":"Coding/C","permalink":"https://askeynil.github.io/categories/Coding/C/"},{"name":"Kinetic","slug":"ROS/Kinetic","permalink":"https://askeynil.github.io/categories/ROS/Kinetic/"},{"name":"BugFix","slug":"BugFix","permalink":"https://askeynil.github.io/categories/BugFix/"},{"name":"OpenCV","slug":"Coding/OpenCV","permalink":"https://askeynil.github.io/categories/Coding/OpenCV/"},{"name":"Shell","slug":"Coding/Shell","permalink":"https://askeynil.github.io/categories/Coding/Shell/"},{"name":"Python","slug":"Coding/Python","permalink":"https://askeynil.github.io/categories/Coding/Python/"},{"name":"Editor","slug":"Editor","permalink":"https://askeynil.github.io/categories/Editor/"},{"name":"Vim","slug":"Editor/Vim","permalink":"https://askeynil.github.io/categories/Editor/Vim/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://askeynil.github.io/categories/Algorithm/"},{"name":"LeetCode","slug":"Algorithm/LeetCode","permalink":"https://askeynil.github.io/categories/Algorithm/LeetCode/"},{"name":"MySQL","slug":"Coding/MySQL","permalink":"https://askeynil.github.io/categories/Coding/MySQL/"}],"tags":[{"name":"ROS2","slug":"ROS2","permalink":"https://askeynil.github.io/tags/ROS2/"},{"name":"CLI Tools","slug":"CLI-Tools","permalink":"https://askeynil.github.io/tags/CLI-Tools/"},{"name":"install","slug":"install","permalink":"https://askeynil.github.io/tags/install/"},{"name":"Git","slug":"Git","permalink":"https://askeynil.github.io/tags/Git/"},{"name":"C++","slug":"C","permalink":"https://askeynil.github.io/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://askeynil.github.io/tags/Python/"},{"name":"Enum","slug":"Enum","permalink":"https://askeynil.github.io/tags/Enum/"},{"name":"ROS","slug":"ROS","permalink":"https://askeynil.github.io/tags/ROS/"},{"name":"URDF","slug":"URDF","permalink":"https://askeynil.github.io/tags/URDF/"},{"name":"xacro","slug":"xacro","permalink":"https://askeynil.github.io/tags/xacro/"},{"name":"roslaunch","slug":"roslaunch","permalink":"https://askeynil.github.io/tags/roslaunch/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://askeynil.github.io/tags/OpenCV/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://askeynil.github.io/tags/Anaconda/"},{"name":"Shell","slug":"Shell","permalink":"https://askeynil.github.io/tags/Shell/"},{"name":"NumPy","slug":"NumPy","permalink":"https://askeynil.github.io/tags/NumPy/"},{"name":"分水岭算法","slug":"分水岭算法","permalink":"https://askeynil.github.io/tags/%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95/"},{"name":"边缘检测","slug":"边缘检测","permalink":"https://askeynil.github.io/tags/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"},{"name":"轮廓提取","slug":"轮廓提取","permalink":"https://askeynil.github.io/tags/%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96/"},{"name":"ROS Service","slug":"ROS-Service","permalink":"https://askeynil.github.io/tags/ROS-Service/"},{"name":"ROS Topic","slug":"ROS-Topic","permalink":"https://askeynil.github.io/tags/ROS-Topic/"},{"name":"ROS command","slug":"ROS-command","permalink":"https://askeynil.github.io/tags/ROS-command/"},{"name":"Vim","slug":"Vim","permalink":"https://askeynil.github.io/tags/Vim/"},{"name":"ROS msg","slug":"ROS-msg","permalink":"https://askeynil.github.io/tags/ROS-msg/"},{"name":"ROS srv","slug":"ROS-srv","permalink":"https://askeynil.github.io/tags/ROS-srv/"},{"name":"CMakeLists","slug":"CMakeLists","permalink":"https://askeynil.github.io/tags/CMakeLists/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://askeynil.github.io/tags/Matplotlib/"},{"name":"SymPy","slug":"SymPy","permalink":"https://askeynil.github.io/tags/SymPy/"},{"name":"Array","slug":"Array","permalink":"https://askeynil.github.io/tags/Array/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://askeynil.github.io/tags/Dynamic-Programming/"},{"name":"LeetCode Easy","slug":"LeetCode-Easy","permalink":"https://askeynil.github.io/tags/LeetCode-Easy/"},{"name":"Database","slug":"Database","permalink":"https://askeynil.github.io/tags/Database/"},{"name":"MySQL","slug":"MySQL","permalink":"https://askeynil.github.io/tags/MySQL/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://askeynil.github.io/tags/PyQt5/"}]}